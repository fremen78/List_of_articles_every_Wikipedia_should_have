Prozesatzeko unitate zentrala, PUZ (ingelesezko siglak, CPU: Central Processing Unit) edo, besterik gabe, prozesadorea, konputagailu digital baten osagaia da eta konputagailuaren programetan dauden aginduak interpretatzen ditu eta datuak prozesatzen ditu. PUZek funtsezko ezaugarria ematen diote konputagailu digitalari (programagarritasuna), eta edozein garaitako konputagailuetan dauden beharrezko osagaietako bat dira, bilketa primarioarekin eta sarrera-irteera dispositiboekin batera. Zirkuitu integratuekin manufakturatutako PUZari mikroprozesadore esaten zaio. 1970eko hamarkadaren erdialdetik, txip bakarreko mikroprozesadoreek ia erabat ordezkatu dituzte PUZ mota guztiak, eta gaur egun, “PUZ” terminoa mikroprozesadore guztietarako erabili ohi da.
“Prozesatzeko unitate zentrala” esamoldeak, oro har, logika-makinen mota jakin bat deskribatzen du; makina horiek konputagailu-programa konplexuak exekutatu ditzakete. Definizio zabal horretan, “PUZ” terminoa oro har erabiltzen hasi baino askoz lehenago zeuden lehenengo ordenagailu asko sartu daitezke arazorik gabe. Edonola ere, terminoa eta siglak gutxienez 1960ko hamarkadaren hasieratik erabili dira informatikaren industrian. PUZen forma, diseinua eta inplementazioa erabat aldatu dira lehenengo ereduetatik, baina euren funtsezko operazioak nahiko antzera jarraitu du.
Lehenengo PUZak neurrira diseinatu zituzten konputagailu handiago baten osagai moduan; normalean konputagailu bakarra bere motakoen artean. Hala ere, PUZak aplikazio jakin baterako neurrira diseinatzeko metodo garesti hori desagertu egin da hein handi batean, eta horren ordez helburu baterako edo hainbatetarako egokitutako prozesadore merkeak eta estandarizatuak garatu dira. Estandarizazio-joera hori transistore diskretuen, konputagailu zentralen eta mikrokonputagailuen garaian hasi zen batez ere, eta asko azkartu zen zirkuitu integratua (IC) ezagun egin zenean; horri esker, PUZ konplexuagoak diseinatu eta fabrikatu daitezke leku txikietan (milimetroetan). PUZak txikiagotu eta estandarizatu egin direnez, bizitza modernoan halako dispositibo digital gero eta gehiago daude, konputazio-makinen aplikazio mugatuak baino askoz haratago. Mikroprozesadore modernoak alde guztietan daude: automobiletan, telebistetan, hozkailuetan, kalkulagailuetan, hegazkinetan, eta baita sakelako telefonoetan, jostailuetan eta bestelakoetan ere.


== Historia ==

PUZ guztiak egoera diskretuekin aritzen dira, eta ondorioz, kommutazio-elementu jakin batzuk behar dituzte egoera horiek bereizteko eta aldatzeko. Transistorearen onarpen komertziala baino lehenago, errele elektrikoak eta huts-hodiak (balbula termoionikoak) kommutazio-elementu gisa erabili ohi ziren. Lehenagoko diseinuak guztiz mekanikoak ziren, eta abiaduraren aldetik errele elektrikoek eta huts-hodiek lehenagoko haien aldean zenbait abantaila zeuzkaten arren, ez ziren fidagarriak hainbat arrazoirengatik. Esate baterako, korronte zuzeneko logika sekuentzialeko zirkuituak egiteko hardware osagarria behar zen kontaktu-errebotearen arazoari aurre egiteko. Bestalde, huts-hodiak, kontaktu-erreboterik ez duten arren, berotu egin behar dira erabat operazional egon aurretik eta batzuetan kale egiten dute eta funtzionatzeari uzten diote guztiz. Normalean, hodi batek kale eginez gero, PUZ diagnostikatu beharko litzateke ondo ez dabilen osagaia aurkitzeko eta ordezkatu ahal izateko. Ondorioz, lehenengo konputagailu elektronikoak (huts-hodietan oinarrituak) azkarragoak ziren oro har, baina ez ziren konputagailu elektromekanikoak (erreleetan oinarrituak) bezain fidagarriak. Hodi-konputagailuek, EDVACek adibidez, zortzi orduro huts egiten zuten batez beste, eta errele-konputagailuek (lehenagokoak eta motelagoak), Harvard Mark Iek adibidez, gutxitan egiten zuten kale. Azkenean, hodian oinarritutako PUZak nagusi izan ziren, abiaduraren inguruko abantaila handiek fidagarritasun-arazoek baino garrantzi handiagoa izan baitzuten. PUZ sinkrono horietako gehienak erloju-maiztasun baxuetan mugitzen ziren diseinu mikroelektroniko modernoekin alderatuta (ikus beherago erloju-frekuentziaren azalpena). Sasoi hartan oso ohikoak ziren 100 KHz-etik 4 MHz-erainoko maila zeukaten erloju-seinalearen maiztasunak, neurri handi batean euren fabrikazioan erabilitako kommutazio-dispositiboen abiadurak mugatuta.


=== Transistoreen eta zirkuitu integratu diskretuen PUZ ===

Hainbat teknologiek dispositibo elektroniko txikiagoak eta fidagarriagoak egitea erraztu zuten heinean, PUZen diseinua konplexuago bihurtu zen. Hobekuntza horietako bat transistorearen agerpena izan zen. 1950eko eta 1960ko hamakadetan transistorizatutako PUZak ez zituzten fabrikatu behar izan bolumen handiko kommutazio-elementu ez fidagarri eta hauskorrekin, huts-hodiekin eta errele elektrikoekin gertatu zen bezala. Hobekuntza horrekin, PUZ konplexuagoak eta fidagarriagoak egin zituzten osagai diskretuak (bakarkakoak) zeuzkaten zirkuitu inpresoko txartel baten edo batzuen gainean.
Sasoi hartan ezaguna egin zen transistore ugari leku konpaktu batean fabrikatzeko metodoa. Zirkuitu integratuari (IC) esker transistore pilo bat fabrikatu ahal izan ziren erdieroalean edo “txipean” oinarritutako olata sinple batean. Hasieran, zirkuitu digital oso oinarrizkoak eta ez espezializatuak txikiagotu zituzten ICetan, NOR ateak adibidez. “Eraikuntza-blokeko” ICetan oinarritutako PUZei, oro har, eskala txikiko integrazioko dispositibo esaten zaie, hau da, "small-scale integration" (SSI). SSI zirkuitu integratuek, Apolloren gida-konputagailuan (Apollo Guidance Computer) erabilitakoek adibidez, hamarren multiploetan zenbatzen ziren transistoreak izan ohi zituzten. SSI ICak erabiliz PUZ oso bat egiteko bakarkako milaka txip behar ziren, baina transistore diskretuen lehenagoko diseinuek baino askoz leku eta energia gutxiago behar ziren. Teknologia mikroelektronikoak aurrera egin ahala, gero eta transistore gehiago jarri ziren ICetan, eta horrela PUZ oso baterako behar zen bakarkako IC kopurua murriztu egin zen. MSI eta LSI zirkuitu integratuek (eskala ertaineko eta handikoek) transistoreen kopurua handitu egin zuten, hasieran ehunka eta gero milaka.
1964an, IBMk System/360 konputagailu-arkitektura sartu zuen; zenbait konputagailutan erabili zen eta konputagailu haiek programa desberdinak exekutatu zitzaketen abiadura eta funtzio desberdinekin. Adierazgarria izan zen hori, garai hartan konputagailu elektroniko gehienak elkarren artean bateraezinak baitziren, baita fabrikatzaile berberak egindakoak ere. Hobekuntza hori errazteko, IBMk mikroprograma-kontzeptua erabili zuen, sarritan “mikrokodea” deitutakoa, eta gaur egun ere askotan erabiltzen da PUZ modernoetan. System/360 arkitektura hain ezagun egin zenez, mainframe-aren merkatuan nagusi izan zen ondoko hamarkadetan eta hark utzitako ondarea antzeko konputagailu modernoek erabiltzen dute oraindik, hala nola IBM zSeries delakoak. 1964 urtean bertan, Digital Equipment Corporation (DEC) enpresak beste konputagailu garrantzitsu bat sartu zuen zientzia- eta ikerketa-merkatuetan: PDP-8. Geroago, DECek PDP-11 linea ezaguna sortu zuen; linea hori, hasieran SSI ICekin egin zuten, baina LSI osagaiekin inplementatu zuten praktikoak izatera heldu zenean. SSI eta MSI teknologiarekin egindako aurrekoek ez bezala, PDP-11ren lehenengo LSI inplementazioak bakarrik lau LSI zirkuitu integratuk osatutako PUZa izan zuen.
Transistoreetan oinarritutako konputagailuek zenbait abantaila zeuzkaten lehenagokoen aldean. Fidagarritasun gero eta handiagoa eta energia-kontsumo txikiagoa izateaz gain, transistoreei esker PUZak askoz azkarrago funtzionatzen zuen, transistoreek hodiek edo erreleek baino kommutazio-denbora laburragoa behar baitzuten. Garai hartan kommutazio-elementu ia guztiak transistoreak ziren, eta haien fidagarritasun gero eta handiagoari eta hainbeste handitutako azkartasunari esker, PUZaren erloju-maiztasunak hamarnaka megahertzekoak izatea lortu zen. Gainera, transistore diskretudun eta zirkuitu integratudun PUZak asko erabiltzen ziren bitartean, errendimendu handiko diseinu berriak agertzen hasi ziren, hala nola, SIMD prozesadore bektorialak (Single Instruction Multiple Data). Hasierako diseinu esperimental horien ondoren superkonputagailu espezializatuen garaia etorri zen, adibidez Cray Inc. konpainiak egindakoak.


=== Mikroprozesadoreak ===

1970ean lehenengo mikroprozesadorea agertu zen, Intel 4004, eta 1974an, asko erabili zen lehenengo mikroprozesadorea, Intel 8080. Ordutik PUZ mota horrek ia guztiz ordezkatu ditu Prozesatzeko Unitate Zentralaren beste inplementazio-metodo guztiak. Garai hartako mainframe eta minikonputagailuen fabrikatzaileek IC jabeen garapen-programak atera zituzten euren konputagailu-arkitekturarik zaharrenak eguneratzeko; era berean, jarraibide-multzoak zeuzkaten mikroprozesadoreak ekoitzi zituzten, eta hardware eta software zaharrenekin bateragarriak ziren. Horren eta gaur egun noranahikoa den konputagailu pertsonalaren agerpen eta arrakasta handiaren ondorioz, “PUZ” terminoa ia mikroprozesadoreetarako bakarrik erabiltzen da orain.
PUZen aurreko belaunaldiak osagai diskretu eta integrazio-eskala txikiko zirkuitu integratu ugari gisa inplementatu ziren zirkuitu-txartel batean edo gehiagotan. Bestalde, mikropozesadoreak ICen oso kopuru txikia erabiliz egindako PUZak dira; normalean bakarrarekin egindakoak. Pastilla huts batean inplementatuta egotearen ondorioz PUZa txikia izateak kommutazio-denbora azkarragoak dakartza faktore fisikoak direla-eta, esate baterako ateen kapazitantzia parasitoaren murrizketa dela-eta. Horri esker, mikroprozesadore sinkronoen erlojuek hamarnaka megahertzeko maila dute zenbait gigahertzetan. Gainera, IC batean transistore txikiegiak egiteko gaitasuna handitu denez, PUZ sinple bateko konplexutasuna eta transistore-kopurua ere ikaragarri handitu da. Joera hedatu hori Moore-en legeak deskribatzen du; lege horrek argi utzi du gaur egunera arte PUZen eta ICen konplexutasuna areagotzeari buruzko aurreikuspen nahiko zehatza.
Azken hirurogei urteotan PUZaren konplexutasuna, tamaina, fabrikazioa eta forma orokorra erabat aldatu diren arren, argi dago diseinua eta oinarrizko funtzionamendua ez direla gehiegi aldatu. Gaur egungo PUZ gehienak Eckert-Mauchly-ko programa metatuko makina gisa deskribatu daitezke zehaztasunez.
Aipatutako Moore-en legeak egiazkoa izaten jarraitzen duen heinean zirkuitu integratuko teknologiaren mugei buruzko ardurak agertu dira. Ate elektronikoen erabateko txikiagotzea esanguratsuago bihurtzen ari diren fenomenoak eragiten ari da, hala nola elektromigrazioa eta galera-azpimuga. Beste arrazoi batzuez gain, ardura horien ondorioz ikertzaileak konputazio-metodo berriak ikertzen ari dira (adibidez konputagailu kuantikoa) eta paralelismoa eta Eckert-Mauchly eredu klasikoa gero eta gehiago erabiltzen dira.


== PUZaren operazioa ==
Edozein forma fisiko dutela ere PUZek funtsezko operazio bat daukate: metatutako aginduen sekuentzia bat exekutatzea, “programa” izenekoa. Eckert-Mauchly arkitekturarekin bat datozen dispositiboez ari gara. Konputagailu-memoria mota batean dauden zenbaitzenbakik programa irudikatzen dute. Eckert-Mauchly ordenagailu ia guztiek lau urrats egiten dituzte operazioetan: fetch, decode, execute, eta writeback, (irakurri, deskodetu, exekutatu eta idatzi).

Lehen urratsaren bidez, irakurri (fetch), agindu bat berreskuratzen da programa-memoriatik (agindua zenbaki batek edo zenbaki-sekuentzia batek irudikatzen du). Programaren memoriako kokapena programaren kontagailu batek (PC) zehazten du, eta kontagailuak zenbaki bat gordetzen du, une bakoitzean programan zer kokapena daukan identifikatzen duena. Beste modu batean esanda, programaren kontagailuak PUZari adierazten dio unean uneko programan agindua zer lekutan dagoen. Agindu bat irakurri ondoren, PCa aginduko hitzaren luzeraren arabera handitzen da memoria-unitatetan. Sarritan, irakurri beharreko agindua memoria nahiko moteletik berreskuratu behar da eta ondorioz PUZa gelditu egiten da agindua itzultzen den bitartean. Prozesadore modernoetan, arazo horri katxeek eta pipeline arkitekturek (ikus beherago) erantzuten diote neurri handi batean.
PUZak memoriatik irakurtzen duen agindua PUZak zer egin beharko duen zehazteko erabiltzen da. Deskodetzearen urratsean, agindua zatikatu egiten da, eta zati horiek PUZaren beste atal batzuetarako esanahia dute. PUZaren agindu-multzoaren (ISA) arkitekturak zenbaki bidezko aginduaren balioa interpretatzeko modua zehazten du. Sarritan, aginduko zenbaki-multzo batek, opcode deitutakoak, zer operazio egin adierazten du. Zenbakiaren beste atalek agindu horretarako eskatzen den informazioa eman ohi dute, adibidez, gehikuntza-operazio baterako eragigaiak. Eragigai horiek balio konstante gisa agertu daitezke (berehalako balioa deitutakoa) edo balio bat kokatzeko leku gisa, helbide-moduren batek zehaztutakoaren arabera erregistro bat edo memoria-helbide bat izan daitekeena. Diseinu zaharragoetan, agindua deskodetzeaz arduratzen ziren PUZaren atalak hardware-dispositibo finkoak ziren. Hala ere, PUZ eta ISA abstraktuago eta korapilatsuagoetan, mikroprograma bat erabili ohi da PUZerako zenbait konfigurazio-seinaletan aginduak interpretatzen laguntzeko. Programa hori, batzuetan, berridatzi egin daiteke PUZak aginduak deskodetzeko darabilen modua aldatu ahal izan dadin, baita fabrikatuta egon eta gero ere.

Irakurri eta deskodetu ondoren, agindua exekutatu egin behar da. Urrats horretan, PUZaren zenbait atal konektatu egiten dira eurek bakarrik nahi den operazioa egin ahal izan dezaten. Adibidez, gehikuntza-operazio bat eskatu bada, unitate aritmetiko-logiko bat (UAL) sarrera-multzo bati eta irteera-multzo bati lotuko zaio. Sarrerek batu beharreko zenbakiak ematen dituzte, eta irteerek azken batura izango dute. UALek sarreretan aritmetikako eta logikako operazio sinpleak egiteko zirkuituak dauzka, esate baterako batuketak eta bitekin operazioak (bitwise) egiteko. Batuketa-operazioaren emaitza PUZak erabil dezan handiegia bada, gainezkatze aritmetikoko bandera (flag) bati egokitu dakioke; bandera hori bandera-erregistro batean egongo da (ikus beherago zenbaki osoen barrutiari buruzko atala).
Azken urratsean, idazketan (writeback), exekuzioaren urratseko emaitzak memoria moduko batean “idazten” dira. Askotan, emaitzak PUZaren barne-erregistroren batean idazten dira ondoren emandako aginduen bidez erraz eskuratzeko. Beste batzuetan, emaitzak memoria nagusi batean idatzi daitezke; memoria hori motelagoa da, baina baita merkeagoa eta handiagoa. Agindu-mota batzuek programaren kontagailua manipulatzen dute, zuzenean emaitzaren datuak sortu ordez. Horiei, normalean, “jauziak” esaten zaie (jumps), eta erraztu egiten dituzte zenbait jokaera, hala nola begiztak (loops), programen baldintzapeko exekuzioa (baldintzapeko jauzien erabileraren bidez) eta funtzioak programetan. Agindu askok, halaber, digituen egoera aldatuko dute “banderen” erregistro batean. Bandera horiek programa baten jokaerarengan eragiteko erabili daitezke, izan ere, sarritan, zenbait operazioren emaitza adierazten dute. Esate baterako, “konparazioko” agindu-mota batek balio bi hartzen ditu kontuan eta zenbaki bat finkatzen du banderen erregistroan, handiena zein den begiratuta. Orduan, bandera hori geroagoko beste jauzi-agindu baterako erabili daiteke, programa-fluxua zehazteko.
Agindua bete eta emaitza gisa eskuratzen diren datuak idatzi ondoren, prozesu osoa hurrengo agindu-zikloarekin errepikatzen da; normalean, sekuentziako hurrengo agindua irakurtzen da programaren kontagailuko balio handituaren arabera. Gauzatutako agindua jauzia bazen, programaren kontagailua aldatu egingo da jauzi egin zen aginduaren helbidea mantentzeko, eta programak normal exekutatzen jarraitzen du. Hemen deskribatutakoa baino PUZ konplexuagoetan, agindu ugari irakurri, deskodetu eta exekutatu daitezke aldi berean. Atal honek deskribatu egiten du normalean “RISC intubatu klasikoa” (Classic RISC pipeline) deitzen dena; hori nahiko ohikoa da dispositibo elektroniko askotan erabiltzen den PUZ sinpleen artean, sarritan mikrokontrolagailu deitutakoetan.


== Diseinua eta inplementazioa ==


=== Osoen barrutia ===
PUZ batek zenbakiak irudikatzeko duen modua diseinu-aukera bat da, eta dispositiboak funtzionatzeko dituen modurik oinarrizkoenei eragiten die. Lehenengo kalkulagailu digitaletako batzuek zenbaki-sistema hamartar arruntaren (hamarreko oinarria) modelo elektriko bat erabiltzen zuten euren baitan zenbakiak irudikatzeko. Beste konputagailu batzuek zenbaki-sistema exotikoagoak erabili dituzte, hirutarra adibidez (hiruko oinarria). PUZ moderno ia guztiek modu bitarrean irudikatzen dituzte zenbakiak; hau da, balio biren kopuru fisiko jakin batek adierazten du digitu bakoitza, boltaje “handi” edo “txikia” bezala.

PUZ batek irudikatu ditzakeen zenbakien tamaina eta zehaztasuna zenbaki bidezko irudikapenarekin lotuta daude. PUZ bitar batean, '''bit''' batek erreferentzia egiten dio PUZ batek lanerako darabiltzan zenbakietako kokapen esanguratsu bati. PUZ batek zenbakiak irudikatzeko darabiltzan bit-kopuruari (edo zenbaki-kokapenen edo digituen kopuruari), sarritan, “hitzaren tamaina”, “bit-zabalera”, “datu-ibilbidearen zabalera”, edo “zenbaki osoaren zehaztasuna” (zenbaki osoez bakarrik arduratzen denean; puntu mugikorreko zenbakiekin kontrajarrita) esaten zaio. Zenbaki hori desberdina da arkitekturen arabera eta, askotan, PUZ berberaren atal desberdinen baitan. Esate baterako, 8 bit dauzkan PUZ batek zortzi digitu bitarrek irudikatu dezaketen zenbaki-barrutia darabil, digitu bakoitzak balio posible bi izanik eta 8 bitak nahastuta 28 edo 256 zenbaki diskretu izanik. Hain zuzen ere, zenbaki osoaren tamainak hardware-muga bat ezartzen du zenbaki osoen barrutian, software-ak hartu dezakeena eta PUZak zuzenean erabili dezakeena.
Zenbaki osoaren barrutiak PUZak helbideratu (kokatu) dezakeen memoriako kokapenen kopuruari ere eragin diezaioke. Esate baterako, PUZ bitar batek memoria-helbide bat irudikatzeko 32 bit badarabiltza, eta memoria-helbide bakoitzak zortzikote (8 bit) bat irudikatzen badu, PUZak helbideratu dezakeen memoria-kopururik handiena 232 zortzikotekoa edo 4 GBkoa da. Hau PUZaren helbide-espazioaren oso ikuspuntu sinplea da, eta diseinu moderno askok helbide-metodo konplexuagoak darabiltzate orrialde-zenbaketa gisa, euren barruti osoak helbide-espazio zapal batekin ahalbidetuko liekeena baino memoria gehiago aurkitzeko.
Zenbaki osoen barrutiaren maila handiagoek egitura gehiago behar dituzte digitu gehigarriak maneiatzeko, eta beraz, konplexutasun, tamaina, energia-erabilera eta, oro har, kostu handiagoa behar dute. Hori dela-eta, 4 eta 8 biteko mikrokontrolagailuak ikusi daitezke aplikazio modernoetan erabilita, askoz barruti handiagoko (16, 32, 64 eta baita 128 biteko) PUZak eskuragarri dauden arren. Mikrokontrolagailurik sinpleenak, oro har, merkeagoak dira, energia gutxiago darabilte eta, ondorioz, bero gutxiago xahutzen dute. Horiek guztiak diseinuzko jarraibide garrantzitsuak izan daitezke dispositibo elektronikoetarako. Hala ere, maila handiko aplikazioetan, barruti gehigarriak (sarriago helbide-espazio gehigarriak) sortutako onurak esanguratsuagoak dira, eta maiz diseinuaren aukerei eragiten diete. Bit-luzera txikienek zein handienek emandako abantailetako batzuk lortzeko, PUZ asko bit-zabalera desberdinez diseinatuta daude dispositiboaren atal desberdinetarako. Esate baterako, IBM System/370ek batez ere 32 biteko PUZa erabili zuen, baina puntu mugikorreko bere unitateen baitan 128 biteko zehaztasuna erabili zuen puntu mugikorreko zenbakien zehaztasun eta barruti handiagoa errazteko. PUZaren geroagoko diseinu askok bit-zabaleraren nahasketa antzekoa darabilte, batez ere prozesadorea helburu orokorreko erabileretarako diseinatuta dagoenean, hor beharrezkoa baita zenbaki osoen eta puntu mugikorreko zenbakien arteko zentzuzko oreka.


=== Erloju-maiztasuna ===
PUZ gehienak, eta, hain zuzen ere, logika sekuentzialeko dispositibo gehienak, izaera sinkronodunak dira. Hau da, sinkronizazio-seinale baten arabera diseinatuta daude eta horren arabera jokatzen dute. Seinale horrek, erloju-seinale deritzonak, uhin karratu periodiko baten forma hartu ohi du. PUZ baten zirkuitu ugarietako bidegurutzeetan seinale elektrikoek mugitzeko behar duten gehienezko denbora kalkulatuz, diseinatzaileek erloju-seinalerako maiztasun egokia aukeratu dezakete.
Seinale batek, kasurik txarrenean, mugitzeko edo hedatzeko behar duen denbora baino luzeagoa izan behar da maiztasun hori. Erloju-maiztasuna kasurik txarrenaren hedapenaren atzerapenean oinarritutako balio batean finkatzean, posiblea da PUZ osoa diseinatzea eta baita datuak erloju-seinalearen igoeraren edo jaitsieraren “ertzen” inguruan mugitzeko modua ere. Horren abantaila da PUZa modu esanguratsuan sinplifikatu daitekeela, bai diseinuaren ikuspuntutik bai osagai-kopuruaren ikuspuntutik. Hala ere, desabantaila ere badu, izan ere, PUZ osoak itxaron egin behar du elementurik motelenen ondorioz, beste atal batzuk askoz azkarragoak izan arren. Muga hori, neurri batean, PUZaren paralelismoa handitzeko zenbait metodok arindu dute (ikus beherago).
Edonola, hobekuntza arkitektonikoek bakarrik ez dituzte konpontzen PUZ globalki sinkronoen desabantaila guztiak. Adibidez, erloju-seinale bat beste edozein seinale elektrikoren atzerapenei lotuta dago. Gero eta PUZ konplexuagoetako erloju-abiadura handiagoek zailagoa egiten dute erloju-seinalea fasean (sinkronizatuan) mantentzea unitate osoaren bitartez. Hori dela-eta, PUZ moderno askok erloju-seinale berdin ugari eman diezazkieten behar dute, seinale bakar bat PUZak oker funtzionatzea eragiteko bezainbeste atzeratu dadin saihesteko. Erloju-abiadura gehiegi handitzen denean beste arazo garrantzitsu bat izan ohi da, zehazki, PUZak xahutzen duen bero guztia. Erlojuaren seinalea etengabe aldatzen da, eta ondorioz, osagai asko kommutatu egiten dira (egoera-aldaketa), kontuan hartu gabe une horretan osagai horiek erabiltzen ari diren ala ez. Oro har, egoera aldatzen ari den osagai batek egoera estatikoan dagoen elementu batek baino energia gehiago erabiltzen du. Ondorioz, erlojuaren abiadura handitzen den heinean, bero gehiago xahutzen da, eta horren eraginez, PUZak konponbide eraginkorragoak behar ditu hozteko.
Beharrezkoak ez diren osagaien kommutazioa tratatzeko metodo bat clock gating izenekoa da; beharrezkoak ez diren osagaiei erlojuaren seinalea itzaltzea eragiten die, eta desaktibatu egiten ditu. Hala ere, sarritan, inplementatzeko zailtzat jotzen da hori, eta beraz, ez dirudi erabilera komunik daukanik potentzia txikiko diseinuetatik kanpo. Erloju-seinale global baten arazoetako batzuk tratatzeko beste metodo bat seinalea erabat kentzea da. Erloju-seinale globala kentzeak, modu askotan, diseinu-prozesua askoz konplexuago egiten duen bitartean (antzeko diseinu sinkronoekin alderatuta), diseinu asinkronikoek (erloju gabeek) abantaila nabarmenak dituzte energia-kontsumoari eta energia-xahutzeari dagokienez. Ez ohikoa den arren, PUZ osoak eraiki dira erloju-seinale global bat erabili gabe. Horren adibide garrantzitsu bi: AMULET, ARMren arkitektura inplementatzen duena, eta MiniMIPS, MIPS R3000 delakoarekin bateragarria dena. Erloju-seinalea erabat kendu ordez, PUZ diseinu batzuek onartu egiten dute dispositiboaren atal batzuk asinkronikoak izatea, adibidez, UAL asinkronikoak erabiltzea pipelining supereskalarrarekin batera zeregin aritmetikoan zenbait onura lortzeko. Ez dago argi diseinu guztiz asinkronikoek euren kontrako alderdi sinkronikoekiko maila konparagarrian edo hobean lan egin dezaketen, baina agerikoa da gutxienez operazio matematikorik sinpleenetan nabarmentzen direla. Horrek, energia-kontsumoaren eta bero-xahutzearen ezaugarri bikainekin batera, oso egokiak egiten ditu konputagailu landatuetarako.


=== Paralelismoa ===

Aurreko atalean PUZ baten oinarrizko operazioari buruz emandako deskribapenak PUZ batek izan dezakeen formarik sinpleena azaltzen du. PUZ mota horrek, normalean azpieskalarra deitutakoak, datu-pieza bat edo bi duen agindu bakarraren gainean operatzen du eta horrelako agindu bakarra exekutatzen du.
Prozesu horrek eraginkortasun eza eratzen du PUZ azpieskalarretan. Agindu bakarra exekutatzen denez, PUZ osoak itxaron egin behar du agindu hori osatu dadin hurrengo aginduarekin hasi aurretik. Ondorioz, PUZ azpieskalarra “geldiarazita” geratzen da exekutatzeko erloju-ziklo bat baino gehiago erabiltzen duten aginduetan. Bigarren exekuzio-unitate bat (ikus beherago) gehituta ere ez da eginkizuna asko hobetzen. Bide bakarra etenda geratu beharrean, horrela bide bi geldiarazten dira eta erabili gabeko transistoreen kopurua handitu egiten da. PUZaren exekuzio-baliabideek agindu bakarrarekin operatu dezaketen diseinu horrek, ziurrenik, eginkizun eskalarra bakarrik lortu dezake (agindu bakarra erloju-zikloko). Hala ere, eginkizuna azpieskalarra izaten da ia beti (agindu bat baino gutxiago zikloko).
Eginkizun eskalarra edo hobea lortzeko ahaleginek PUZari ez hain linealki eta paraleloago jokarazten dioten diseinu-metodologiak dituzte emaitza moduan. PUZetako paralelismoaz hitz egitean, normalean termino bi erabiltzen dira diseinu-teknika horiek sailkatzeko.

Aginduen mailako paralelismoak, ingelesez Instruction Level Parallelism (ILP), aginduak PUZ baten baitan exekutatzen direneko tasa handitzea bilatzen du, hau da, exekuzio-baliabideen erabilera handitzea pastillan.
Exekuzio-hariaren mailako paralelismoak, ingelesez Thread Level Parallelism (TLP), PUZ batek aldi berean exekutatu ditzakeen harien kopurua handitzea du helburutzat (banakako programak hain zuzen ere).
Metodologia bakoitza desberdina da bai inplementatuta dagoen moduan, bai aplikazio baterako PUZaren eginkizunaren areagotzean sortzen duen eraginkortasun erlatiboan.


==== ILP: Agindu-intubatua eta arkitektura azpieskalarra ====

Paralelismoa lortzeko erabilitako metodorik sinpleenetakoa da agindua irakurtzen eta deskodetzen hastea aurreko agindua exekutatzen amaitu baino lehenago. Instruction pipelining (agindu-intubatua) izeneko teknika baten modurik sinpleena da, eta helburu orokorreko PUZ moderno ia guztietan erabiltzen da. Exekuzio-bidea etapa diskretuetan zatitzean, tutueriak agindu bat baino gehiago edozein unetan exekutatzea ahalbidetzen du. Banaketa hori mihiztadura-linea batekin alderatu daiteke; bertan, agindu bat gero eta osoagoa egiten da etapa bakoitzean, exekuzio-tutueriatik irteten den arte eta kentzen duten arte.
Edonola ere, tutueriak aukera ematen du beharrezkoa izan dadin aurreko operazioaren emaitza amaituta egotea hurrengo operazioa gauzatzeko; baldintza horri, sarritan, datuen menpekotasun-arazoa esaten zaio. Horri aurre egiteko, arreta berezia jarri behar zaio baldintza-mota horiek egiaztatzeari, eta hala gertatuz gero, aginduen tutueriaren zati bat atzeratu egin behar da. Hori lortzeko, noski, beharrezkoak dira zirkuitu osagarriak, eta prozesadore intubatuak azpieskalarrak baino konplexuagoak dira, baina ez askoz gehiago. Prozesadore intubatu bat ia guztiz eskalarra izatera heldu daiteke, tutueriaren geldialdiek bakarrik inhibituta (etapa batean erloju-ziklo bat baino gehiago irauten duen agindu bat).

Agindu-intubatuaren (instruction pipelining) ideiaren inguruan egindako hobekuntza osagarri batek PUZaren osagaien geldialdi-denbora are gehiago murrizten duen metodoa garatzea eragin zuen. Supereskalartzat jotzen diren diseinuek agindu-tutueria luzea dute eta exekuzio-unitate berdin ugari. Tutueria supereskalar batean, agindu ugari irakurtzen dira eta aztergailu batera bidaltzen dira; aztergailuak aginduak paraleloan (aldi berean) exekutatu daitezkeen ala ez erabakitzen du. Hala izanez gero, exekuzio-unitate eskuragarrietara bidaltzen dira, eta horren ondorioa da hainbat agindu aldi berean exekutatzeko gaitasuna. Oro har, PUZ supereskalar bat itxaroten dauden exekuzio-unitateetara aldi berean gero eta agindu gehiago bidaltzeko gai izan, agindu gehiago osatuko dira ziklo jakin batean.
PUZaren arkitektura supereskalar bat diseinatzearen alderik zailena aztergailu eraginkorra sortzea da. Aztergailuak azkar eta zuzen erabaki behar du aginduak paraleloan exekutatu daitezkeen, eta ahalik eta exekuzio-unitate gehien lanean egoteko moduan bidali behar ditu agindu horiek. Ondorioz, beharrezkoa da agindu-tutueria ahalik eta gehienetan betetzea, eta hori dela-eta, are beharrezkoagoa da arkitektura supereskalarretan PUZ katxearen kopuru esanguratsuak izatea. Halaber, horrek arriskuak saihesteko teknikak eratzen ditu, hala nola, adarkatze-aurreikuspena, exekuzio espekulatiboa, eta ordenarik gabeko exekuzioa, eta biziki garrantzitsuak dira eginkizun-maila handiak mantentzeko.

Adarkatze-aurreikuspenaren bidez aurreikusi nahi da ea zer adarrek (edo bidek) hartuko duen baldintzazko agindua. PUZak baldintzazko agindu bat bete arte tutueria osoak itxaron behar duen denbora murriztu dezake.
Exekuzio espekulatiboak, sarritan, eginkizuna areagotzen du modu apalean, baldintzazko operazio bat amaitu eta gero beharrezkoak izan daitezkeen kode-atalak exekutatzean.
Ordenarik gabeko exekuzioak aldatu egiten du neurri batean aginduak betetzeko ordena, datuen menpekotasunaren ondorioz atzerapenik egon ez dadin.
PUZaren atal bat supereskalarra denean eta beste bat ez, supereskalarra ez den atalak jardueran kaltea jasaten du ordutegiaren geldialdiak direla-eta. Intel Pentium originalak (P5) UAL supereskalar bi zeuzkan, eta bakoitzak agindu bat onar zezakeen erloju-ziklo bakoitzeko, baina bere FPUk (Puntu Mugikorreko Unitateak) ezin zuen onartu agindu bat erloju-ziklo bakoitzeko. Ondorioz, P5 supereskalarra zen zenbaki osoen aldean, baina ez zen supereskalarra puntu mugikorreko zenbakietan. Intel Pentiumaren arkitekturaren ondorengoak, P6k, gaitasun supereskalarrak erantsi zizkion puntu mugikorreko funtzioei, eta ondorioz, puntu mugikorreko aginduen jardueran areagotze nabarmena eragin zuen.
Intubatu sinpleak eta diseinu supereskalarrak PUZ baten ILPa handitzen dute, prozesadore bakarrari ahalbidetu egiten baitiote ziklo bakoitzeko agindu bat (IPC) baino ratio handiagoetan aginduak exekutatzea. PUZen diseinu moderno gehienak gutxienez pixka bat supereskalarrak dira,eta azken hamarkadan, helburu orokorreko PUZ diseinu ia guztiak supereskalarrak dira. Azken urteotan, ILP handiko konputagailuen diseinuaren garrantziaren zati bat PUZaren hardwaretik softwarearen interfazerantz (ISA) mugitu da. Agindu-hitz oso luzearen estrategiak (very long instruction word, VLIW) eragin egiten dio ILPren bati softwareak zuzenean inplizitua izatea, eta PUZak egin beharreko lan-bolumena murrizten du ILPri bultzada garrantzitsua emateko eta ondorioz diseinuaren konplexutasuna murrizteko.


==== TLP: Harien aldibereko exekuzioa ====
PUZen paralelismoa areagotzeko askotan erabiltzen den beste estrategia bat hari (programa) ugari aldi berean mugitzeko gaitasuna da. Oro har, TLP handiko PUZak ILP handikoak baino askoz luzaroago erabili dira. Seymour Cray aitzindaria izan zen diseinu askotan 1970eko hamarkadaren amaieran eta 1980ko hamarkadan, eta diseinu horiek TLPan zentratu ziren konputazio-gaitasun erraldoiak errazteko bere metodo primario gisa (bere denborarako). Hain zuzen ere, TLP, exekuzio-hari ugarien hobekuntza-formetan, 1950eko hamarkadatik erabili izan da; aspalditxo beraz. Banakako prozesadoreen diseinuan, TLP lortzeko erabili diren metodologia nagusi biak honakoak dira: multiprozesatzea txiparen mailan, ingelesez chip-level multiprocessing (CMP), eta aldibereko multihariztatzea, ingelesez simultaneous multithreading (SMT). Maila handi batean, oso ohikoa da egiten diren konputagailuek PUZ guztiz independenteak izatea multiprozesatze simetrikoa (symmetric multiprocessing, SMP) edo memoria-sarbide ez uniformea (Non-Uniform Memory Access, NUMA) bezalako esparruetan. Oso baliabide desberdinak erabiltzen diren arren, teknika horiek guztiek helburu berbera lortzen dute: PUZak paraleloan mugitu ditzakeen harien kopurua handitzea.
CMP eta SMP paralelismo-metodoak antzekoak dira elkarren artean eta oso zuzenak. PUZ oso eta PUZ independente bi edo gehiago erabiltzea baino zerbait kontzeptualagoa dakarte. CMPri dagokionez, prozesadorearen “nukleo” ugari pakete berberean sartzen dira, batzuetan zirkuitu integratu berberean. Bestalde, SMPk pakete independente ugari dauzka. NUMA SMPren antzekoa da, baina memoria-sarbide ez uniformea darabil. Hori garrantzitsua da PUZ asko dituzten konputagailuetarako, prozesadore bakoitzaren memorian sartzeko behar den denbora berehala agortzen baita SMPren memoria partekatuaren modeloarekin, eta atzerapen handia eragiten du memoriaren ondorioz zain dauden PUZengatik. Beraz, NUMA modeloak arrakastaz ahalbidetzen du SMPk modu eraginkorrean jasan ditzakeen PUZ guztiak baino askoz gehiago erabiltzea. SMT pixka bat bereizi daiteke TLPren beste hobekuntza batzuetatik, ahalik eta PUZ atal gutxien bikoizten saiatzen baita. TLP estrategia bat erabiltzen den bitartean, bere inplementazioa, benetan, diseinu supereskalar baten antzekoa da, eta hain zuzen ere, sarritan erabiltzen da mikroprozesadore supereskalarretan, IBMren POWER5en esate baterako. PUZ osoa bikoiztu beharrean, SMT diseinuek irakurtzeko, deskodetzeko eta aginduak emateko behar diren piezak baino ez dituzte bikoizten, eta helburu orokorreko erregistroetako gauzak. Horri esker, SMT PUZ batek sarriago izan ditzake jardunean bere exekuzio-unitateak, software-hari desberdin bitatik ematen baitizkie aginduak. Beste behin ere, hori ILPren metodo supereskalarraren oso antzekoa da, baina aldi berean exekutatzen ditu hainbat haritako aginduak hari berbereko agindu ugari exekutatu beharrean.


=== Prozesadore bektorialak eta SIMD ===
Bada beste PUZ paradigma bat (eta hain zuzen ere, konputazio orokorrekoa), ez hain ohikoa baina gero eta erabiliagoa, eta bektoreekin dihardu. Aurretik aipatu diren prozesadoreak dispositibo eskalar gisa aipatu dira. Izenak dioen legez, prozesadore bektorialak datu-pieza ugarirekin lan egiten dute agindu baten testuinguruan, eta hori prozesadore eskalarrekin kontrajarrita dago, haiek datu-pieza bakarra baitarabilte agindu bakoitzeko. Datuak lantzeko eskema bi horiek, oro har, horrela izendatzen dira: SISD (Single Instruction, Single Data) (Agindu Sinplea, Datu Sinplea) eta SIMD (Single Instruction, Multiple Data) (Agindu Sinplea, Datu Ugari). Datu-bektoreez arduratzen diren PUZak sortzea oso erabilgarria da, horrela operazio bera behar duten eginkizunak optimizatzen baitira, adibidez, datu-multzo handi batean egin beharreko batuketa bat edo produktu eskalar bat. Eginkizun-mota horien adibide klasiko batzuk: multimedia aplikazioak (irudiak, bideoa eta soinua) eta zeregin zientifiko ugari nahiz ingeniaritzarekin lotutako zereginak. PUZ eskalar batek agindu eta balio bakoitza datu-multzo batean irakurtzeko, deskodetzeko eta exekutatzeko prozesu osoa bete behar duen bitartean, PUZ bektorial batek operazio sinple bat egin dezake konparazioan handiagoa den datu-multzo batean agindu bakarraren bidez. Hori, noski, aplikazioak operazio bat datu-multzo handi bati aplikatzen dioten urrats ugari behar dituenean baino ez da posible.
Lehenengo PUZ bektorial gehienak, Cray-1 adibidez, zientzia-ikerketako eta kriptografiako aplikazioekin bakarrik lotu ziren ia. Hala ere, multimedia neurri handi batean bitarteko digitaletarantz joan zen heinean, oso beharrezko bihurtu da SIMD forma jakin bat helburu orokorreko PUZetan. Helburu orokorreko prozesadoreetan puntu mugikorreko unitateak sartzen hasi eta gutxira, SIMD exekuzio-unitateen espezifikazioak eta inplementazioak agertzen hasi ziren erabilera orokorreko PUZetarako. Lehenengo SIMD espezifikazio horietako batzuk, Intelen MMX adibidez, zenbaki osoetarako bakarrik izan ziren. Horrek agerian utzi zuen oztopo esanguratsua zela software-garatzaile batzuetarako, SIMDaren onurak erabiltzen zituzten aplikazio askok batez ere puntu mugikorreko zenbakiekin lan egiten baitzuten. Pixkanaka, hasierako diseinu horiek findu eta berregin egin ziren SIMD espezifikazio komun eta modernoetakoren batean, normalean ISA bati lotuta daudenetako batean. Adibide moderno nabarmen batzuk Intelen SSE eta PowerPCrekin lotutako AltiVec (VMX izena ere baduena) dira.


== Ikus,gainera ==
Bus
CISC
RISC
Konputagailu arkitektura
Txartel nagusi
Multiplataforma
Mikroprozesadore


== Kanpo estekak ==