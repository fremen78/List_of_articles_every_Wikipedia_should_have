CPU（シーピーユー、英: Central Processing Unit）、中央処理装置（ちゅうおうしょりそうち）または中央演算処理装置（ちゅうおうえんざんしょりそうち）は、コンピュータの主要な構成要素で、データの演算やコンピュータ内の装置の制御などを行う装置。コンピュータにおける中心的な処理装置（プロセッサ）。


== 概要 ==
「CPU」の意味は、厳密に言うと、「プロセッサ」や「マイクロプロセッサ」とは意味が異なっており、範囲の違いがある。
もともとは、コンピュータの中央処理装置（CPU）は、ディスクリート（ダイオードやトランジスタなど、単機能の個別半導体で構成された電子回路）から成るかなり大きなサイズの電子回路で作られた。やがて集積回路を作れるようになると、それを使い中央処理装置を作るようになった。（なお、大型汎用機を指す「メインフレーム」という語は、もともとは多数の架（フレーム）から成る大型汎用機システムにおいてCPUの収まる主要部（メイン）、という所から来ている。）　さらに大規模集積回路（LSI）を作れるようになると、やがてCPUの機能を含んだマイクロプロセッサを製造できるようになり、それがCPUとして使われている（ただしマイクロプロセッサはCPU以外の用途で使われているほうがはるかに数が多い。例えばPCの電源部に内蔵されている制御用マイクロコントローラはマイクロプロセッサの一種だが、PCのCPUではない。）

機能と動作

CPUは記憶装置上にあるプログラムと呼ばれる命令列を順に読み込んで解釈・実行することで情報の加工を行なう。CPUはコンピュータ内での演算を行なう中心であり、CPUは通常はバスと呼ばれる信号線を介して主記憶装置や入出力回路に接続され、何段階かの入出力回路を介して補助記憶装置や表示装置、通信装置などの周辺機器が接続され、データやプログラムなど情報のやりとりを行なう。
このようなCPUを用いたプログラムによるコンピュータの逐次動作がほとんどのコンピュータの基本的な動作原理となっている。記憶装置上にプログラムを配置してから、プログラムを実行する方式をプログラム内蔵方式と言う。
現在のCPUは、部品としてはプロセッサの1種である。プロセッサの多くはマイクロチップとして実装されており、マイクロプロセッサやMPU (Micro Processing Unit) と呼ばれる。また、算術演算機能を強化し信号処理に特化したデジタルシグナルプロセッサ (DSP) や、メモリや周辺回路を搭載し組込機器制御を目的としたマイクロコントローラ（マイコン）などの展開種も登場している。
専用の電子回路に比べると実行速度は遅いが、プログラムを変えるだけで多様な処理が行なえることから、非常に多岐にわたる用途に使用できる汎用性と柔軟性が最大の特徴である。専用回路（ハードウェア）の変更・修正に比べれば、ソフトウェアの変更・修正は容易であり、物質的なコストがかからないため、システム設計・開発の試行錯誤もしやすい。このため、CPUはおよそあらゆるシステムに内蔵され、現代の産業や生活の屋台骨を支える存在にまで普及している。現在最も普及しているCPUアーキテクチャとしてARMアーキテクチャが挙げられる。ARMアーキテクチャベースのCPUは1991年から数え2008年初頭に出荷個数が100億個を超えるなど、家電製品から工業製品、携帯機器などに至る多くのシステムに組み込まれ、機器制御を司っている。また、パーソナルコンピュータ (PC) など、現在の汎用コンピュータ製品における多くのシステムのメインCPUにx86アーキテクチャが用いられており、インテルのx86系CPU出荷数は1978年6月9日の8086発売から2003年までの25年で10億個を越えた。
いわゆるノイマン型・プログラム内蔵方式のプロセッサの構造と基本動作は、世界で最初の実用的なノイマン型・プログラム内蔵方式のコンピュータであったEDSACの実装の時点で、すでに構造と基本動作が実装されている。CPUやCPU以外のプロセッサの発達には、プロセス技術の微細化による高速化、命令の各処理工程の並列実行（命令パイプライン、演算パイプライン）、命令の並列実行（スーパースケーラ、VLIW）、データ演算の並列化（SIMD演算）、複数プロセッサ・コアの実装（マルチコア）、複数スレッドの同時実行（同時マルチスレッディング）などやその他多数の要素がある。


== 構造と動作 ==


=== 構造 ===
CPUは、全体を制御する制御装置、演算装置、データを一時記憶するレジスタ、メモリなどの記憶装置とのインタフェース、周辺機器との入出力装置とのインタフェース、などから構成される。
その他 浮動小数点演算を行うFPU（浮動小数点演算ユニット）、レジスタより多くの情報を一時記憶するキャッシュメモリ、DMAコントローラ、タイマー、シリアルインタフェースなどの機能をCPUと同一IC内に持つものもある。また、メモリから読み込んだ命令語を内部的なオペレーションに置き換える変換部を持つものもある。
クロック同期型のCPUは、クロック信号によって規則正しいタイミングで各部の動作を統制されている。
同じアーキテクチャのCPUであればクロック周波数が高い方が高速に動作し、一定時間に多くのことを処理できる。ただしその代わりに消費電力や発熱が大きくなるという問題も発生する。
1クロックで処理できる内容はCPUおよび命令セットの設計により異なり、複数クロックで1つの機械語命令を実行するものから、1クロックで複数の命令を同時に実行できるものまである。クロック周波数が1 GHzのCPUは、基本回路が1秒間に10億回の動作をする。
多くのCPUでは、大まかに言って制御装置が命令の解釈とプログラムの制御の流れを制御し、演算装置が演算を実行する。
高性能なCPUや、非ノイマン型のCPUや、画像処理向けのCPUは、同時に複数の命令を実行できるように複数の実行部を同一IC内に持っているものがある。


=== 動作 ===
ノイマン型CPUの基本的な動作は、その実装に関わらずプログラムと呼ばれる命令列を順番に実行することである。
プログラムは数値列として何らかのメモリに格納されている。CPUでは、フェッチ (fetch)、デコード (decode)、実行 (execute) という3つのステップがほぼ必ず存在する。
最初の段階であるフェッチとは、実行すべき命令（ある数値または数値の並び）をプログラムの置かれたメモリから取り出すことである。メモリ上の実行すべき命令の位置はプログラムカウンタで指定される。プログラムカウンタはCPUが現在見ているプログラム上の位置を示しているとも言える。命令フェッチに使用されると、プログラムカウンタはフェッチしたぶんだけ増加させられる。
CPUがメモリからフェッチした命令によってCPUの次にすべきことが決定される。デコードでは、命令をCPUにとって意味のある形式に分割する。命令を表す数値をどう分割するかは、予めそのCPUの命令セットで決定される。命令の一部の数値は命令コードと呼ばれ、実行すべき処理を指定する。その他の部分はオペランドと呼ばれ、その命令で使用する情報を示している。たとえば加算命令のオペランドは加算すべき数値を示している。オペランドには数値そのものが書かれていたり、数値のある場所（メモリのアドレスかレジスタの番号）が書かれている。古い設計では、デコーダ（デコードを行う部分）は変更不可能なハードウェア部品だった。しかし、より複雑で抽象的なCPUや命令セットではマイクロプログラム方式がしばしば使われ、命令を様々な信号に変換するのを助けている。このマイクロプログラムは書き換え可能な場合があり、製造後でも命令デコード方法を変更することができる。
フェッチとデコードの次は、実行ステップが行われる。このステップでは、CPUの多くの部分が接続され（たとえばマルチプレクサを切り替えるなどして）指定された操作を実行する。たとえば、加算を要求されている場合、加算器が所定の入力と接続され、出力と接続される。入力は加算すべき数値を提供し、出力には加算結果が格納される。加算結果が大きすぎてそのCPUに扱えない場合、算術オーバーフローフラグをフラグレジスタ（ステータスレジスタ）にセットする（RISCではフラグレジスタが存在しない場合もある）。入力や出力にはいろいろなものが使用される。演算結果が一時的かあるいはすぐに利用される場合にはレジスタと呼ばれる高速で小さなメモリ領域に格納される。メモリも入力や出力に使われる。レジスタ以外のメモリは低速だが、コスト的には一般的なメモリの方が安価であり大量のデータを格納できるため、コンピュータには必須である。
いくつかの命令はプログラムカウンタを操作する。それらは一般にジャンプ命令と呼ばれ、ループを構成したり、条件分岐をしたり、サブルーチンを実現するのに使われる。また、多くの命令はフラグレジスタを変化させる。それらのフラグはプログラムの動作に影響を与える。たとえば比較命令は二つの値を比較してフラグレジスタにその大小を示す値をセットする。そして、その値を使用してその後の処理の流れを決定する。
命令を実行後、同じ流れが繰り返されて次の命令をプログラムカウンタにしたがってフェッチする。もっと複雑なCPUでは、複数の命令をフェッチし、デコードし、同時に実行することもできる。しかし、基本的にどんなCPUでもやっていることはここで説明した流れと同じである。


== 歴史 ==

現代のCPUのような装置が出てくる以前、ENIACのような計算機は、実行する処理の内容を変えるたびに物理的に配線を変更していた。このような機械では、プログラムを変更するために物理的に再構成する必要がある（たとえばENIACなどではパッチパネルが使われた）ことから「プログラム固定計算機」と呼ばれることがある（なお、ENIACは非常に限られた機能と性能になるが、ある程度はプログラム内蔵方式的な動作もできた）。
CPUは一般にソフトウェア（プログラム）を実行する装置として定義されるため、CPUと呼べる装置が現れたのはプログラム内蔵方式のコンピュータからである。プログラム内蔵方式の考え方は、ENIACの設計時にすでに存在していたが、マシンの完成を早期に可能とするため、ENIACの初期段階で採用されなかった。ENIACが完成する以前の1945年6月30日、数学者のジョン・フォン・ノイマンの名で、EDVACに関する報告書の第一草稿 (First Draft of a Report on the EDVAC) という報告書が公開・配布された。この中で、プログラム内蔵方式のコンピュータの設計について概説されている。この報告書はEDSACなどに影響を与えた。EDVACは1949年8月に一応の完成を見、アバディーンに移された。EDVACは様々な命令の集まりを実行するよう設計されていた。命令を組み合わせることで実用的なプログラムを構成し、EDVACで動作させることができた。EDVACではプログラムは高速なメモリに格納されており、物理的に配線を変更することで指定されるものではない点が重要である。ノイマン型の設計では、EDVACで動作させるプログラムを変更するにはメモリを書き換えればよかった（ノイマン型はプログラム内蔵だけでなく、プログラムがデータとして書き換え可能である点まで含む点に注意）。
結果としてノイマン型で先に完成したのは、EDSAC (1949年) やManchester Mark Iの試作機 Baby (1948年) であった。EDVACは先に設計が始まっているが、設計者間のごたごたがあって完成が遅れた。また、アイデアレベルではZuse Z3を1941年に開発しているコンラッド・ツーゼもそれ以前にプログラム内蔵方式（書き換えでない点に注意）を考案していた。データとプログラムを同じ記憶装置に格納するかどうかという点が異なる方式として、ハーバード・アーキテクチャがある。これはEDVAC以前に完成したHarvard Mark Iに由来する。同機ではさん孔テープにプログラムを格納した。ノイマン型とハーバード型の大きな違いは、後者が命令とデータの格納場所と扱いを完全に分離していることであり、前者はどちらも同じ記憶領域に格納する。汎用CPUは基本的にノイマン型であるが、ハーバード・アーキテクチャも部分的に採用されている（キャッシュメモリなど）。
デジタル機器としてのCPUは、状態を変更したり表現したりするために、何らかのスイッチを必要とする。電気機械式から電子式への移行期には、リレーや真空管がスイッチとして使われた。これらは、従来の完全な機械式よりも高速にスイッチを切り替えられたが、チャタリングをはじめ、コイル（インダクタ）によって発生する高電圧などの問題があった。一方、真空管はチャタリングは起こさないが、機能するには熱が必要であり、劣化により動作中にカソードの電子放射能力が減退（エミッション減退）して動作不能になってしまう。真空管が劣化・故障したら、故障した部位を特定して交換しなければならない。したがって、初期の電子計算機は高速化は実現したものの、電気機械式計算機よりも信頼性が低かった。EDVACのような真空管計算機は故障と故障の間の平均時間（MTBF = Mean Time Between Failure）は約 8 時間であったが、Harvard Mark Iのようなリレー式計算機はほとんど故障しなかった。しかし、信頼性よりも性能が重視され、真空管式計算機が主流となっていった。当時の同期式CPUのクロック周波数は現在のCPUに比較すると非常に遅く、100 kHz〜4 MHz程度であった。これは、当時の論理素子（真空管）のスイッチング速度によって限界が定められていた。


=== 半導体化 ===
小型で信頼性の高い電子部品を使うことで、CPUの設計と複雑さの進歩がもたらされた。新たに発明され急激に性能の向上したトランジスタの利用である。これによって、1950年代から1960年代には、かさばって信頼性の低い真空管やリレーはほとんど使われなくなった。この改善によってさらに複雑で信頼性のあるCPUを一枚から数枚のプリント基板で構成できるようになった。
1964年、IBMが発表したSystem/360アーキテクチャは、いろいろな性能と大きさのコンピュータとして実装され、それらのシリーズではプログラムを変更することなく動作させることができた。当時、たとえ同じメーカーであっても、サイズの違うコンピュータは互換性がないのが普通だった。この改善を成し遂げるため、IBMはマイクロプログラム方式を採用した。これは現在のCPUでも広く使われている手法である。System/360は大変な成功を収め、その後数十年間メインフレーム市場を支配し続け、現在のz/Architectureに至っている。
同じ1964年、DECも、「PDP-8」という後世に影響を与えたミニコンピュータを、科学分野や研究分野に向けてリリースした。DECは、後にさらに広く使われることとなる「PDP-11シリーズ」を発表したが、このシリーズは、後に集積回路（IC）が使えるようになると、それを使ったバージョンも製造されている。トランジスタを使ったCPUでは、新たな設計上の工夫をする余裕が生じ、SIMDやベクトル計算機と呼ばれるものが出現した。そのような初期の実験的設計は、後にクレイ社の製造したスーパーコンピュータのベースとなっている。
トランジスタを使ったコンピュータは、それ以前のものと比較していくつかの明確な利点があった。信頼性向上と消費電力低下はもちろん、トランジスタによるスイッチは切り替え時間が劇的に短縮されたため、CPUが高速化された。トランジスタによるコンピュータでは動作周波数は数十MHzまで高速化された。


=== マイクロプロセッサ ===

CPUなどに使われるプロセッサは、1970年代に1チップの大規模集積回路（LSI）に集積されるようになった（マイクロプロセッサ）。初期のマイクロプロセッサは4ビットや8ビットで、当時のミニコンピュータやメインフレームのCPUに比べると非常に機能の限られたものであったが、1970年代末から1980年代の微細化の進展により、プロセス保護など当時のメインフレームに相当するような機能を統合した32ビットプロセッサが現れた。組み込み用途には周辺機能やメモリ等を集積した、いわゆるワンチップマイコンも普及した。初期のマイクロプロセッサはNMOSロジック回路で構成されていたが、1980年代にはCMOS化が進み、消費電力が激減した（CMOSは消費電力は抑えられるが、当初は遅かったことから、電卓や時計など消費電力が重要で速度が重要でない分野でしか使われなかった）。CMOSは微細化が進めば進むほど静電容量が減り高速化でき、高速化を狙わない場合は低消費電力化できるという優れた特長があり（デナード則）、動作周波数は2000年代にはGHzオーダーまで上がった。微細化はより多くのゲートを載せることができるということでもあり、命令パイプラインやアウト・オブ・オーダー実行などで命令レベルの並列性を引き出す、複雑で高性能なプロセッサが作られるようにもなった。微細化による集積度の向上の傾向はムーアの法則により定性的にモデル化されている。ただし複雑化に比例して性能が線形に上がるわけではない（ポラックの法則）。しかし、2006年頃にはデナード則が崩れて、動作周波数の向上とマイクロアーキテクチャの複雑化で性能向上を図る方向性は行き詰まった。以降は非対称型を含むマルチコア化と、相対的に低いクロックでも高い性能を引き出しやすいSIMDの性能向上に力点が置かれている。

マイクロプロセッサの複雑さ、機能、構造、一般的な形状はこの50年間で劇的に変化したが、CPUの高性能化の基本的なコンセプトは、マイクロプロセッサ以前の1960年代に初めて現れた、というものが多い。たとえば、アウト・オブ・オーダー実行の方式であるscoreboardingもTomasuloのアルゴリズムも、最初に考案されたのは1960年代である。


== 設計と実装 ==


=== ビット幅 ===

21世紀現在のコンピュータは、ほぼ全てが二値論理方式であり、そのうちのほぼ全てが数の表現法として二進法を二値論理にマッピングして演算などを行っている。電卓用に特別に設計されたマイコンやメインフレームなどには、広義の二進化十進表現のような方式でハードウェアで十進の計算を行う機能が強化されているものもある。1ビットが二進法の1桁である。ビット数を「ビット幅」などとも呼ぶ。
例えば、「ビット幅」や「データバス幅」が8ビットであるため8ビットCPUと呼ばれるCPUでは、主なレジスタ等の幅、あるいは、データバスの幅が8ビットである。8ビットでは、非負整数であれば二進法8桁で表せる範囲である「2の8乗 − 1」まで、つまり［0 〜 255］の範囲の整数が表現できる。
また「アドレス幅」はCPUが直接にメモリを指し示す（アドレッシングする）範囲を制限する。例えば、アドレス幅が32ビットのCPUでは、そのCPUが直接指定できるアドレスの範囲は、2の32乗、つまり4,294,967,296個の異なる位置になる。
System/360以降の多くの命令セットアーキテクチャ（ISA）では1バイトがアドレス付けの単位であるため（バイトアドレッシング）、4ギビバイトのメモリに、直接アクセスできる、ということになる。
これらはCPUのデータ幅やアドレス幅による単純な分類方法であり、実際のCPUではデータ信号線やアドレス指定方法に工夫することで、外部的に少ないデータバス幅や内部的に少ないアドレス幅でも効率的にメモリ・アクセスできるようにしているものがあるため、こういった分類は多少複雑になっている。
CPUを表現する場合のビット数の意味は以下の通りである。

アドレス幅（内部のアドレスレジスタ幅、外部アドレスバス幅）
データバス幅（内部データ幅、外部データバス幅）
内部演算幅（＝演算装置の幅と整数レジスタ幅）
命令語長
1990年代以降は4ビットから64ビットまで多様なビット幅のCPUが製品化されている。高ビット幅のCPUは機能や性能が高い反面、高集積化や回路の複雑度から高価格で消費電力も大きく、低ビット幅のCPUは機能や性能が制限される代わりに安価で低消費電力であるなど特徴があり、状況に応じて使い分けられている。
1990年代後半から21世紀に入って、パーソナルコンピュータ用CPUで一般化した、いくぶん新たなCPU高速化技術については、複数CPUの搭載（マルチコア）やVLIW、スーパースケーラなどがある。これらはメインフレームなどの大型計算機ではずっと前から一般的だったが、PC用の技術として降りてくるまでにはプロセス微細化の発展や製造コスト低下を待たなければならなかった。


==== 用途例 ====
CPUのビット数による用途の例を示す。

4ビット
1980年代を中心に、一般的な家電製品、キーボードやマウス、電卓や時計など、ローエンドの組み込みシステムに広く用いられた。家電用の赤外線リモコンなど機能的に単純なものについては4ビットのマイクロプロセッサでも十分であるが、既に新規採用の事例はほとんどなくなっている。
8ビット、16ビット
機器組み込み向けに8ビットや16ビットのプロセッサ・コアと周辺回路を組み合わせたマイクロコントローラ (MCU) と呼ばれるものが広く使用されている。いずれも要求仕様と製造原価との兼ね合いで都合の良いサイズのプロセッサが選定され製造される。だが、この用途でも32ビットマイクロプロセッサの価格低下、旧来用いてきた半導体の製造終了、要求仕様の高度化や汎用開発ツールの援用要求により、あえて32ビット以上のCPUを選択するケースも少なくない。
32ビット
携帯電話やデジタルカメラをはじめ、自動車のエンジン制御や産業用ロボット、工作機械、白物家電など組み込みシステムや大小さまざまなシステムの制御に幅広く用いられており、狭義のCPUと呼ばれるものの主要な使用例である。
2000年代以降の半導体製造技術の進歩に伴い、ローエンドの32ビットプロセッサと16/8ビットプロセッサの価格差は少なくなっており、16ビット命令（ARMのThumb命令など）を持つ32ビットプロセッサがMCU用途にも広く使われるようになっている。
2010年代の高性能・多機能化した情報機器には、メインのCPUの他にしばしばペリフェラル（カメラなどのセンサ類や、ストレージ、ディスプレイ、ネットワークなどの周辺デバイス）制御用の32ビットMCUが組み込まれている。また、IoTデバイスの構成単位としてセンサやアクチュエータに組み込まれるMCUへの性能要求も高度化している。こうしたことから世の中に出回っている32ビットプロセッサの数は膨大である。
64ビット
パーソナルコンピュータ (PC)、ワークステーション、サーバ、スーパーコンピュータをはじめ、タブレットやスマートフォンなどの「スマートデバイス」と総称される情報機器、ルータなどのネットワーク機器、ゲーム機など、大量のデータを処理する用途で使われている。
業務用のサーバでは大きな主記憶容量が求められたため、1990年代からCPUとオペレーティングシステム (OS) の64ビット化が進められていたが、一般消費者向けのPCにも浸透したのは2000年代中盤以降である。2010年代以降、市販されているPCは64ビットCPUを搭載するものがほとんどであるが、オフィススイートなどの用途ではアプリケーションソフトウェアを64ビット化してもパフォーマンス向上の恩恵が得られる場面は限られており、また互換性の問題（32ビット版のアドオンが利用できなくなるなど）の回避のために、32ビット版アプリケーションが推奨されているケースもある。一部のプラットフォームでは、64ビットOS上の32ビットエミュレーションレイヤーを介して32ビットアプリケーションを実行することもできるため、すべてのアプリケーションを64ビット化しなければならないというわけではない。また、64ビット版のデバイスドライバが提供されていない周辺機器があるなどの問題から、64ビットCPUを搭載していながらも32ビット版のOSを利用しなければならないケースもある。ただし、画像処理や動画編集など大量のデータを処理する用途では、巨大なメモリを割り当てることができる64ビット化のメリットは大きく、これらのアプリケーションソフトウェアは比較的早い時期から64ビット化が進んだ。2019年現在では、32ビット版デバイスドライバのサポートや更新が打ち切られているケースもある。
スマートフォンも普及の初期は32ビットCPUが用いられたが、2013年9月に発表されたiPhone 5sを皮切りに64ビットCPUへの対応と移行が進んでおり、iOSのように32ビット版アプリケーションの動作サポートを打ち切ったり、Androidのように64ビット版アプリケーションの提供を義務付けたりするプラットフォームもある。
上記の分類に当てはまらないものとして、過去には、互いに結合し自由にビット長を増やす事ができる方式のCPUがあり、これはビットスライスプロセッサと呼ばれた。代表的な製品にAMDのAM2900シリーズなどが挙げられる。AM2901は、スイス連邦工科大学のLilithワークステーション等に使用されていた。またデータをバイト単位で扱うCPU（バイトマシン）の他、ワード単位で扱うCPU（ワードマシン）もある（日本電気のACOS-6など）。


=== 低消費電力化 ===


==== 低電圧化 ====
最も基本的なCPUの低消費電力化技術は低電圧化であった。ロジック動作の信号線の電圧を低電圧化することは、低消費電力化につながると同時に信号を"Hi"と"Low"の間で高速に変更できるため動作速度の向上にも寄与した。
当初はリレーのような数十ボルトの動作電圧だったが、1980年代には5 Vがデジタルコンピュータの標準的な動作電圧となり、1990年代には内部回路が3 V程度の低電圧化を取り入れはじめ、外部との信号線でも同様の低電圧化が行なわれる頃には、CPUの内部ではさらに低い電圧が採用されるようになった。2000年代末には内部的には1 V弱まで低電圧化が進められ、当時はノイズ耐性を考慮すればほぼ限界であると考えられていたが、その後もマイクロプロセッサの低電圧化の趨勢は続き、2013年に登場したQuark X1000は最低0.28 Vの超低電圧動作が可能である。


==== クロックゲーティング ====
ほとんどのCPU（もっと言えばほとんどの順序回路）は同期式である。つまり、CPUは同期信号にしたがって動作するよう設計されている。この信号は「クロック信号」として知られていて、一定周期の矩形波の形であることが多い。電気信号の伝播速度からCPU内の信号経路の長さを考慮してクロック信号の周波数が決定される。この周波数は信号伝播の最悪ケースを考慮して決めなければならない。最悪ケースを考慮して周波数を決定すれば、CPU全体が波形のエッジ部分で動作するよう設計でき、CPUの設計を簡略化できると同時にトランジスタ数も減らすことができる。しかし、この設計手法の欠点としてCPU全体が最も遅い部分を待つように設計しなければならず、全体の高速化がその遅い部分によって制限される。この制限に対処するために命令パイプラインやスーパースケーラといった手法が採られてきた。
パイプラインだけでは同期式CPUの問題を全て解決することはできない。たとえば、クロック信号は他の電気信号の遅延に影響される。クロック周波数が高くなり、さらに複雑なCPUを動作させようとしたとき、全回路を同期させるのが困難になってきた。このため、新たな高性能CPUでは1つのクロック信号でCPU全体を同期するのではなく、いくつかのクロック信号で各部分を個別に同期させるようにしている。また、クロック周波数が高くなるにつれてCPUの発熱が大きな問題となってきた。クロック信号が"Hi"と"Low"を繰り返すことで多くのロジック回路が同様に"Hi"と"Low"を繰り返し、その回路が演算処理に使われていない時でもクロック信号が供給されている間は無駄に動作して発熱する。21世紀現在CPUに使用されている半導体回路では、信号電圧を"Hi"か"Low"に保持し続けるよりも"Hi"から"Low"や"Low"から"Hi"へ移る時に多くの電気エネルギーを消費する。このため、CPUに高速処理能力を求めるとクロック周波数が高くなり発熱も多くなって、さらに冷却する必要が生じる。
つまり、無駄にクロック信号を供給することを止めれば電力消費は抑えられ発熱も小さくなる。このように、演算処理に関与しない不要ブロックへのクロック信号の供給を止めるクロックゲーティングと呼ばれる手法がある。


==== パワーゲーティング ====
2000年代後半以降に登場した高性能CPUで使用されている半導体回路技術（プロセス技術）では、消費電力に対するリーク電流の比率が大きくなった。リーク電流はクロック信号の有無に関係が無いため、クロックゲーティングだけでは大きな電力削減効果は得られない。
このような高性能CPUでは、クロック信号の供給停止だけではなく、動作していないモジュール等への電源供給そのものを遮断するパワーゲーティングと呼ばれる技術が必要になる。従来は、高性能化したCPUが消費する大電流をロジック回路に最適化された半導体回路技術（プロセス技術）で制御することは容易ではなかったが、リーク電流対策として2000年代末までには広く用いられる技術になった。


==== 非同期設計 ====
クロック信号で全体を一斉に動かすのをやめる、という手もある。非同期設計には独特の手法が必要で、同期設計と比較すると非常に難しい点があるが、消費電力と発熱の面で大きな利点がある。SRAMなどでは、クロックと関係なくアクセスできたほうが扱いに便利な場合もあり、非同期SRAMはごく一般的な製品である。また演算回路など、一般的なプロセッサ内部の一部に使われることもある。
一般に市販された製品としては、非同期設計を表に出したマイクロプロセッサはあまり一般的ではないが、研究室での試作といったレベルでは研究・試作はさかんに行われており、日本のものでは南谷らによるTITACなどが知られている。海外ではマンチェスター大によるARMベースのAMULETは（技術的ではない理由で中止にはなっているが）市販品に使用される予定があった。他にMIPS（R3000）ベースのMiniMIPSなどがある。
クロックを完全に無くするのではなく部分的に非同期化することで性能を高める工夫としては、非同期演算装置を使ってスーパースカラーのパイプラインを構成することで演算性能を上げようとした設計などがある。同期動作するCPUに比較して性能が向上するかどうかは定かではないが、少なくとも原理的には効果が期待できる。


=== 並列化 ===


== MCU ==
CPUを中心に拡張された電子部品にマイクロコントローラ（MCU）がある。
このMCUはCPUに加えてプログラム格納用を含む半導体メモリやGPIOとシリアルIO、DAC/ADCといった各種入出力機能にタイマーやDMACにクロック回路、必要に応じてDSPやフラッシュメモリなどの周辺回路を1つのパッケージに内蔵して、主に小型の組込機器の制御に使用される。


== 比喩 ==
比喩的表現だが、CPUは、コンピュータの「頭脳」に例えられることが多い。
コンピュータゲームの世界では、コンピュータやソフトウェアが動かす対戦相手や敵ユニットをCPUと呼ぶこともある。


== 企業および製品 ==


== 脚注 ==


=== 注釈 ===


=== 出典 ===


== 参考文献 ==

ジョン・L・ヘネシー／デイビッド・A・パターソン著、富田眞冶／村上和彰／新實治男訳、『コンピュータ・アーキテクチャ　設計・実現・評価の定量的アプローチ』、日経BP社、ISBN 4-8222-7152-8
デイビッド・A・パターソン／ジョン・L・ヘネシー著、成田光彰訳、『コンピュータの構成と設計　ハードウエアとソフトウエアのインタフェース　第3版(上／下)』、日経BP社、ISBN 4-8222-8266-X/ISBN 4-8222-8267-8
マイク・ジョンソン著、村上和彰監訳、『スーパスカラ・プロセッサ- マイクロプロセッサ設計における定量的アプローチ -』、日経BP社、ISBN 4-8227-1002-5
中森章著、『マイクロプロセッサ・アーキテクチャ入門　RISCプロセッサの基礎から最新プロセッサのしくみまで TECHI Vol.20』、CQ出版社、ISBN 4-7898-3331-3
渡波 郁、『CPUの創りかた』 毎日コミュニケーションズ, 2003, ISBN 978-4839909864


== 関連項目 ==


== 外部リンク ==
『CPU』 - コトバンク