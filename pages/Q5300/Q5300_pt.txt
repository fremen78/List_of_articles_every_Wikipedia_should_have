A unidade central de processamento (UCP) ou Central Processing Unit (CPU), também conhecida como processador, é a parte de um sistema computacional, que realiza as instruções de um programa de computador, que executar a aritmética básica, orientado por um padrão binário 0 e 1 que possibilita a entrada, o processamento e saída de dados. O papel da CPU pode ser comparado ao papel de um cérebro no funcionamento de um computador. Isto é, realiza operações lógicas, cálculos e processamento de dados. O termo foi cunhado no início de 1960 e seu uso permanece até os dias atuais pois, ainda que sua forma, desenho e implementação tenham mudado drasticamente, seu funcionamento fundamental permanece o mesmo.


== Conceito ==
As primeiras CPUs personalizadas foram concebidas como parte de um computador maior. No entanto, este método caro de fazer CPUs personalizadas para uma determinada aplicação rumou para o desenvolvimento de processadores produzidos em massa que são feitos para um ou vários propósitos. Esta tendência de padronização em geral começou na época de discretos minicomputadores e mainframes transistors e acelerou rapidamente com a popularização dos circuitos integrados (CI).
Os CI têm permitido processadores cada vez mais complexos para serem concebidos e fabricados em tamanhos da ordem de nanômetros. Tanto a miniaturização como a padronização dos processadores têm aumentado a presença destes dispositivos digitais na vida moderna, muito além da aplicação limitada dedicada a computadores. Os microprocessadores modernos aparecem em tudo, desde automóveis até celulares e brinquedos para crianças.
Em máquinas grandes, CPUs podem exigir uma ou mais placas de circuito impresso. Em computadores pessoais e estações de trabalho de pequeno porte, a CPU fica em um único chip de silício chamado de microprocessador. Desde 1970 a classe de microprocessadores de CPUs quase completamente ultrapassou todas as implementações de outra CPUs. CPUs modernas são circuitos integrados de grande escala em pequenos pacotes retangulares, com vários pinos de conexão.
Uma CPU é composta basicamente, pela maioria dos autores, pelos três seguintes componentes:

Unidade lógica e aritmética (ULA ou ALU): executa operações lógicas e aritméticas;
Unidade de controle (UC): decodifica instruções, busca operandos, controla o ponto de execução e desvios;
Registradores: armazenar dados para o processamento.
OBS.: Alguns autores também incluem, na mesma categoria dos Registradores, a Memória cache (L1, L2 e L3) como componentes da CPU.


== História ==

Computadores como o ENIAC tinham que ser fisicamente religados a fim de realizar diferentes tarefas, por isso estas máquinas são muitas vezes referidas como "computadores de programa fixo". Visto que o termo "CPU" é geralmente definido como um dispositivo para execução de um software (programa de computador), os primeiros dispositivos que poderiam muito bem ser chamados CPUs vieram com o advento do computador com programa armazenado.
A ideia do programa de computador já estava presente no projeto do ENIAC de J. Presper Eckert e John William Mauchly, mas inicialmente foi omitido para que a máquina pudesse ser concluída em menos tempo. Em 30 de junho de 1945, antes do ENIAC ter sido concluído, o matemático John von Neumann distribuiu um documento intitulado "primeiro esboço de um relatório sobre o EDVAC". É descrito o projeto de um programa de computador armazenado que viria a ser concluído em agosto de 1949. O EDVAC foi projetado para executar um determinado número de instruções (ou operações) de vários tipos. Estas instruções podem ser combinados para criar programas úteis para o EDVAC para ser executado.
Significativamente, os programas escritos para EDVAC foram armazenados em memórias de computador de alta velocidade  e não especificados pela ligação física do computador. Isso superou uma grave limitação do ENIAC que era o longo tempo e esforço necessário para reconfigurar o computador para executar uma nova tarefa. Com o design de von Neumann, o programa, ou software, que executava no EDVAC poderia ser mudado simplesmente mudando o conteúdo da memória do computador.
Enquanto von Neumann é mais frequentemente creditado como sendo o desenvolvedor do computador com programa armazenado, devido à sua concepção do EDVAC, outros antes dele, como Konrad Zuse, tinham sugerido e implementado ideias semelhantes. A chamada arquitetura de Harvard do Harvard Mark I, que foi concluída antes do EDVAC, também utilizou um projeto de programa armazenado usando fita de papel perfurado em vez de memória eletrônica. A diferença fundamental entre as arquiteturas de von Neumann e Harvard é que este último separa o armazenamento e o tratamento de instruções da CPU e de dados, enquanto a primeira utiliza o mesmo espaço de memória para ambos. A maioria dos processadores modernos são principalmente von Neumann em design, mas elementos da arquitetura de Harvard são comumente vistas também.
Como um dispositivo digital, uma CPU é limitada a um conjunto de estados discretos, e requer algum tipo de elemento de comutação para diferenciar e mudar estados. Antes do desenvolvimento comercial do transistor, relés elétricos e válvulas eletrônicas eram comumente utilizados como elementos de comutação.
Embora estes tivessem considerável vantagem em termos de velocidade sobre o que se usava antes, desenhos puramente mecânicos, eles não eram confiáveis por diversas razões. Por exemplo, a construção de circuitos de lógica sequencial de corrente contínua fora de relés requer um hardware adicional para lidar com os problemas de contato. Enquanto as válvulas não sofrem rejeição de contato, elas devem aquecer antes de se tornarem plenamente operacionais, e eventualmente deixam de funcionar devido à lenta contaminação dos seus cátodos que ocorre no curso da operação normal. Se uma válvula selada vaza, como por vezes acontece, a contaminação do cátodo é acelerada.
Normalmente, quando um tubo apresenta defeito, a CPU teria que ser examinada para localizar o componente que falhou a fim de que pudesse ser substituído. Portanto, os primeiros computadores eletrônicos (baseados em válvulas) eram geralmente mais rápidos, mas menos confiáveis do que os computadores eletromecânicos (baseados em relés).
Computadores baseados em válvulas como o EDVAC tendiam a trabalhar em média oito horas até apresentarem falhas, enquanto os computadores baseados em relés como o (mais lento, mas anterior) Harvard Mark I apresentava defeitos muito raramente. No final, CPUs baseadas em válvulas tornaram-se dominantes porque as vantagens de velocidade significativa oferecidas geralmente superavam os problemas de confiabilidade. A maioria destas antigas CPUs funcionava com baixa frequências de relógio em comparação com os design microeletrônicos modernos. Sinais de frequência de relógio variando de 100 kHz a 4 MHz eram muito comuns nesta época, em grande parte limitados pela velocidade dos dispositivos de comutação que eram construídos.


=== CPUs baseadas em transistores discretos e em circuitos integrados ===

A complexidade do projeto de CPUs aumentou quando várias tecnologias facilitaram a construção de menores e mais confiáveis dispositivos eletrônicos. O primeiro aprimoramento veio com o advento do transistor. CPUs transistorizadas durante os anos 1950 e 1960 já não precisavam mais ser construídas com volumosos, não confiáveis e frágeis elementos de comutação, tais como válvulas e relés elétricos. Com esta melhoria, CPUs mais complexas e mais confiáveis foram construídas em uma ou várias placas de circuito impresso com componentes discretos (individuais).
Durante este período, um método de fabricação de transistores em um espaço compacto ganhou popularidade. O circuito integrado (IC, conforme iniciais em inglês) permitiu que um grande número de transistores fossem fabricados em um único die baseado em semicondutor, ou "chip". No início apenas circuitos digitais não especializados e muito básicos, tais como portas NOR foram miniaturizados em ICs. CPUs baseadas nestes IC de "blocos construídos" eram geralmente referidos como dispositivos de "integração em pequena escala" (SSI, conforme iniciais em inglês). SSI ICs, tais como os usados no computador orientado Apollo, normalmente continham somas de transistores em múltiplos de dez.
Para construir uma CPU inteira fora dos SSI ICs eram necessários milhares de chips individuais, mas ainda assim consumiam muito menos espaço e energia do que modelos anteriores baseados em transistores discretos. Quando a tecnologia microeletrônica avançou, um crescente número de transistores foram colocados em ICs, diminuindo assim a quantidade de ICs individuais necessários para uma CPU completa. Circuitos integrados MSI e LSI (integração em média e em larga escala, conforme iniciais em inglês) aumentaram a soma de transistores às centenas, e depois milhares.


== Microprocessadores ==

A introdução do microprocessador na década de 1970 afetou significativamente a concepção e implementação de processadores. 
Com a introdução do primeiro microprocessador disponível comercialmente (o Intel 4004) em 1970 e, posteriormente, do primeiro microprocessador de 16 bits (o Intel 8080), em 1974, os microprocessadores rapidamente tomaram o mercado e se consolidaram com o tipo de CPU mais utilizado, tornando-se praticamente sinônimos.
Microprocessadores utilizam circuitos integrados de transistores, alcançando assim as vantagens dos processadores de transistores ao mesmo tempo que economizam espaço, energia e aquecem menos. Por esses motivos, podem também atingir frequências de clock maiores, o que se traduz em mais operações executadas por segundo e, consequentemente, mais velocidade perceptível ao usuário.
O menor tamanho também possibilitou a inclusão de memória cache, o que possibilita um circuito atingir maior velocidade na execução de programas sem com isso precisar recorrer à frequências de clock maiores. Como clocks maiores significam mais energia consumida e maior calor dissipado, os ganhos de desempenho resultantes da inclusão destas memórias foram essenciais para o surgimento do smartphone. 


== Operação ==
A operação fundamental da maioria das CPUs, independentemente da forma física que assumem, é executar uma sequência de instruções armazenadas que é chamada de programa. As instruções a serem executadas são mantidas em algum tipo de memória de computador. Quase todas as CPUs seguem as etapas de busca, decodificação e execução em sua operação, conhecidas coletivamente como ciclo de instrução.
Após a execução de uma instrução, todo o processo se repete, com o próximo ciclo de instrução normalmente buscando a próxima instrução na sequência devido ao valor incrementado no contador de programa. Se uma instrução de salto for executada, o contador de programa será modificado para conter o endereço da instrução para a qual foi saltado e a execução do programa continua normalmente. Em CPUs mais complexas, várias instruções podem ser buscadas, decodificadas e executadas simultaneamente. Esta seção descreve o que geralmente é referido como "pipeline RISC clássico", que é bastante comum entre as CPUs simples usadas em muitos dispositivos eletrônicos (frequentemente chamados de microcontroladores). Ignora em grande parte o papel importante do cache da CPU e, portanto, a etapa de acesso do pipeline.
Algumas instruções manipulam o contador de programa em vez de produzir dados diretamente; tais instruções são geralmente chamadas de "saltos" e facilitam comportamentos do programa como loops, execução condicional do programa (através do uso de um salto condicional) e existência de funções. Em alguns processadores, outras instruções mudam o estado dos bits em um "registrador de status". Essas flags podem ser usadas para influenciar como um programa se comporta, pois geralmente indicam o resultado de várias operações. Por exemplo, em tais processadores, uma instrução de "comparação" avalia dois valores e define ou limpa bits no registrador de status para indicar qual é maior ou se são iguais; uma dessas flags poderia então ser usada por uma instrução de salto posterior para determinar o fluxo do programa.


=== Busca ===
Busca envolve recuperar uma instrução (que é representada por um número ou sequência de números) da memória do programa. A localização da instrução (endereço) na memória do programa é determinada pelo contador de programa (chamado de "ponteiro de instrução" nos microprocessadores Intel x86), que armazena um número que identifica o endereço da próxima instrução a ser buscada. Após uma instrução ser buscada, o PC é incrementado pelo comprimento da instrução para que contenha o endereço da próxima instrução na sequência. Frequentemente, a instrução a ser buscada deve ser recuperada de uma memória relativamente lenta, causando a paralisação da CPU enquanto espera que a instrução seja retornada. Esse problema é amplamente abordado em processadores modernos por caches e arquiteturas de pipeline (ver abaixo).


=== Decodificação ===

A instrução que a CPU busca na memória determina o que a CPU fará. Na etapa de decodificação, realizada por um circuito de decodificador binário conhecido como decodificador de instrução, a instrução é convertida em sinais que controlam outras partes da CPU.
A maneira como a instrução é interpretada é definida pela arquitetura do conjunto de instruções (ISA) da CPU. Frequentemente, um grupo de bits (ou seja, um "campo") dentro da instrução, chamado de opcode, indica qual operação deve ser realizada, enquanto os campos restantes geralmente fornecem informações suplementares necessárias para a operação, como os operandos. Esses operandos podem ser especificados como um valor constante (chamado de valor imediato) ou como a localização de um valor que pode ser um registrador de processador ou um endereço de memória, conforme determinado por algum modo de endereçamento.
Em alguns designs de CPU, o decodificador de instrução é implementado como um circuito de decodificador binário fixo e imutável. Em outros, um microprograma é usado para traduzir instruções em conjuntos de sinais de configuração da CPU que são aplicados sequencialmente ao longo de vários pulsos de clock. Em alguns casos, a memória que armazena o microprograma é regravável, possibilitando a alteração da maneira como a CPU decodifica as instruções.


=== Execução ===
Após as etapas de busca e decodificação, a etapa de execução é realizada. Dependendo da arquitetura da CPU, isso pode consistir em uma única ação ou uma sequência de ações. Durante cada ação, sinais de controle habilitam ou desabilitam eletricamente várias partes da CPU para que possam realizar toda ou parte da operação desejada. A ação é então concluída, tipicamente em resposta a um pulso de clock. Muito frequentemente, os resultados são escritos em um registrador interno da CPU para acesso rápido por instruções subsequentes. Em outros casos, os resultados podem ser escritos em uma memória principal mais lenta, porém menos cara e de maior capacidade.


== Estrutura e implementação ==

Integrado ao circuito de uma CPU está um conjunto de operações básicas que ela pode executar, chamado de conjunto de instruções. Tais operações podem envolver, por exemplo, adicionar ou subtrair dois números, comparar dois números ou saltar para uma parte diferente de um programa. Cada instrução é representada por uma combinação única de bits, conhecida como opcode da linguagem de máquina. Durante o processamento de uma instrução, a CPU decodifica o opcode (via um decodificador binário) em sinais de controle, que orquestram o comportamento da CPU. Uma instrução completa da linguagem de máquina consiste em um opcode e, em muitos casos, bits adicionais que especificam argumentos para a operação (por exemplo, os números a serem somados no caso de uma operação de adição). Subindo na escala de complexidade, um programa de linguagem de máquina é uma coleção de instruções de linguagem de máquina que a CPU executa.
A operação matemática real de cada instrução é realizada por um circuito de lógica combinacional dentro do processador da CPU conhecido como unidade aritmética e lógica ou ALU. Em geral, uma CPU executa uma instrução buscando-a na memória, usando sua ALU para realizar uma operação e, em seguida, armazenando o resultado na memória. Além das instruções para matemática de inteiros e operações lógicas, várias outras instruções de máquina existem, como aquelas para carregar dados da memória e armazená-los de volta, operações de ramificação e operações matemáticas em números de ponto flutuante realizadas pela unidade de ponto flutuante (FPU) da CPU.


=== Unidade de controle ===

A unidade de controle (CU) é um componente da CPU que direciona a operação do processador. Ela informa à memória do computador, à unidade aritmética e lógica e aos dispositivos de entrada e saída como responder às instruções que foram enviadas ao processador.
Ela direciona a operação das outras unidades fornecendo sinais de temporização e controle. A maioria dos recursos do computador é gerenciada pela CU. Ela direciona o fluxo de dados entre a CPU e os outros dispositivos. John von Neumann incluiu a unidade de controle como parte da arquitetura de von Neumann. Nos designs modernos de computadores, a unidade de controle é tipicamente uma parte interna da CPU, com seu papel e operação geral inalterados desde sua introdução.


=== Unidade aritmética e lógica ===

A unidade aritmética e lógica (ALU) é um circuito digital dentro do processador que realiza operações aritméticas inteiras e operações de lógica bit a bit. As entradas para a ALU são as palavras de dados a serem operadas (chamadas de operandos), informações de status de operações anteriores e um código da unidade de controle indicando qual operação realizar. Dependendo da instrução sendo executada, os operandos podem vir de registradores internos da CPU, memória externa ou constantes geradas pela própria ALU.
Quando todos os sinais de entrada se estabilizam e se propagam através do circuito da ALU, o resultado da operação realizada aparece nas saídas da ALU. O resultado consiste tanto em uma palavra de dados, que pode ser armazenada em um registrador ou memória, quanto em informações de status que são tipicamente armazenadas em um registrador interno especial da CPU reservado para esse propósito.
As CPUs modernas geralmente contêm mais de uma ALU para melhorar o desempenho.


=== Unidade de geração de endereços ===
A unidade de geração de endereços (AGU), às vezes também chamada de unidade de computação de endereços (ACU), é uma unidade de execução dentro da CPU que calcula endereços de memória usados pela CPU para acessar a memória principal. Ao ter cálculos de endereços tratados por circuitos separados que operam em paralelo com o resto da CPU, o número de ciclos de CPU necessários para executar várias instruções de máquina pode ser reduzido, trazendo melhorias de desempenho.
Enquanto realizam várias operações, as CPUs precisam calcular endereços de memória necessários para buscar dados da memória; por exemplo, as posições na memória de elementos de matriz devem ser calculadas antes que a CPU possa buscar os dados dos locais reais da memória. Esses cálculos de geração de endereços envolvem diferentes operações aritméticas de inteiros, como adição, subtração, operações módulo ou deslocamento de bit. Frequentemente, calcular um endereço de memória envolve mais de uma instrução de máquina de uso geral, que não necessariamente decodificam e executam rapidamente. Ao incorporar uma AGU em um design de CPU, juntamente com a introdução de instruções especializadas que usam a AGU, vários cálculos de geração de endereços podem ser descarregados do resto da CPU e muitas vezes podem ser executados rapidamente em um único ciclo de CPU.
As capacidades de uma AGU dependem de uma CPU específica e sua arquitetura. Assim, algumas AGUs implementam e expõem mais operações de cálculo de endereços, enquanto outras também incluem instruções especializadas mais avançadas que podem operar em múltiplos operandos ao mesmo tempo. Algumas arquiteturas de CPU incluem múltiplas AGUs para que mais de uma operação de cálculo de endereços possa ser executada simultaneamente, o que traz melhorias adicionais de desempenho devido à natureza superescalar dos designs avançados de CPU. Por exemplo, a Intel incorpora múltiplas AGUs em suas Sandy Bridge e Haswell microarquiteturas, o que aumenta a largura de banda do subsistema de memória da CPU, permitindo que múltiplas instruções de acesso à memória sejam executadas em paralelo.


=== Unidade de gerenciamento de memória (MMU) ===

Muitos microprocessadores (em smartphones e computadores desktop, laptop e servidor) têm uma unidade de gerenciamento de memória, traduzindo endereços lógicos em endereços físicos de RAM, proporcionando habilidades de proteção de memória e paginação, úteis para memória virtual. Processadores mais simples, especialmente microcontroladores, geralmente não incluem uma MMU.


=== Cache ===
Um cache de CPU é um cache de hardware usado pela unidade central de processamento (CPU) de um computador para reduzir o custo médio (tempo ou energia) para acessar dados da memória principal. Um cache é uma memória menor e mais rápida, mais próxima de um núcleo do processador, que armazena cópias dos dados de locais de memória principal frequentemente usados. A maioria das CPUs possui diferentes caches independentes, incluindo cache de instruções e cache de dados, onde o cache de dados geralmente é organizado como uma hierarquia de mais níveis de cache (L1, L2, L3, L4, etc.).
CPUs modernas (rápidas) possuem múltiplos níveis de cache (com algumas exceções especializadas)
As primeiras CPUs que usavam cache tinham apenas um nível de cache; diferente dos caches L1 posteriores, ele não era dividido em L1d (para dados) e L1i (para instruções). Quase todas as CPUs atuais com cache possuem um cache L1 dividido. Elas também possuem caches L2 e, para processadores maiores, caches L3. O cache L2 geralmente não é dividido e funciona como um repositório comum para o cache L1 já dividido. Cada núcleo de um Processador multinúcleo possui um cache L2 dedicado e geralmente não é compartilhado entre os núcleos. O cache L3 e caches de nível superior são compartilhados entre os núcleos e não são divididos. Um cache L4 atualmente é incomum e geralmente está na memória DRAM (memória dinâmica de acesso aleatório) em vez de memória SRAM (static random-access memory), em um chip ou die separado. Esse também era o caso historicamente com o L1, enquanto chips maiores permitiram a integração dele e geralmente de todos os níveis de cache, com a possível exceção do último nível. Cada nível extra de cache tende a ser maior e otimizado de forma diferente.
Existem outros tipos de caches (que não são contados no "tamanho do cache" dos caches mais importantes mencionados acima), como o translation lookaside buffer (TLB) que faz parte da unidade de gerenciamento de memória (MMU) que a maioria das CPUs possui.
Caches geralmente são dimensionados em potências de dois: 2, 8, 16 etc. KiB ou MiB (para tamanhos maiores que não sejam L1), embora o IBM z13 tenha um cache de instrução L1 de 96 KiB.


=== Frequência de clock ===

A maioria das CPUs são circuitos síncronos, o que significa que elas utilizam um sinal de clock para cadenciar suas operações sequenciais. O sinal de clock é produzido por um circuito oscilador externo que gera um número consistente de pulsos por segundo na forma de uma onda quadrada periódica. A frequência dos pulsos de clock determina a taxa na qual uma CPU executa instruções e, consequentemente, quanto mais rápido o clock, mais instruções a CPU executará por segundo.
Para garantir a operação adequada da CPU, o período do clock é maior que o tempo máximo necessário para todos os sinais se propagarem (moverem) através da CPU. Ao definir o período do clock para um valor bem acima do pior caso de atraso de propagação, é possível projetar toda a CPU e a maneira como ela move dados em torno das "fronteiras" do sinal de clock ascendente e descendente. Isso tem a vantagem de simplificar a CPU significativamente, tanto do ponto de vista do projeto quanto do ponto de vista da contagem de componentes. No entanto, também traz a desvantagem de que toda a CPU precisa esperar por seus elementos mais lentos, mesmo que algumas partes dela sejam muito mais rápidas. Essa limitação foi amplamente compensada por vários métodos de aumento do paralelismo da CPU (veja abaixo).
No entanto, melhorias arquitetônicas por si só não resolvem todas as desvantagens das CPUs globalmente síncronas. Por exemplo, um sinal de clock está sujeito aos atrasos de qualquer outro sinal elétrico. Maiores taxas de clock em CPUs cada vez mais complexas tornam mais difícil manter o sinal de clock em fase (sincronizado) em toda a unidade. Isso levou muitas CPUs modernas a exigirem que vários sinais de clock idênticos sejam fornecidos para evitar atrasar um único sinal significativamente o suficiente para causar o mau funcionamento da CPU. Outro problema importante, à medida que as taxas de clock aumentam dramaticamente, é a quantidade de calor dissipada pela CPU. O clock em constante mudança faz com que muitos componentes mudem de estado independentemente de estarem sendo usados naquele momento. Em geral, um componente que está mudando de estado usa mais energia do que um elemento em um estado estático. Portanto, à medida que a frequência do clock aumenta, também aumenta o consumo de energia, fazendo com que a CPU necessite de mais dissipação de calor na forma de soluções de resfriamento.
Um método para lidar com a mudança de componentes desnecessários é chamado de clock gating, que envolve desligar o sinal de clock para componentes desnecessários (efetivamente desabilitando-os). No entanto, isso geralmente é considerado difícil de implementar e, portanto, não é comum fora de projetos de baixíssima potência. Um projeto de CPU recente notável que usa clock gating extensivo é o Xenon baseado em PowerPC da IBM usado no Xbox 360; isso reduz os requisitos de energia do Xbox 360. 


=== CPUs sem clock ===
Outro método para lidar com alguns dos problemas com um sinal de clock global é a remoção completa do sinal de clock. Embora a remoção do sinal de clock global torne o processo de design consideravelmente mais complexo em muitos aspectos, os designs assíncronos (ou sem clock) trazem vantagens marcantes no consumo de energia e dissipação de calor em comparação com designs síncronos similares. Embora pouco comuns, CPUs totalmente assíncronas foram construídas sem usar um sinal de clock global. Dois exemplos notáveis são o AMULET compatível com a família de arquiteturas ARM e o MiniMIPS compatível com MIPS R3000. 
Em vez de remover totalmente o sinal de clock, alguns projetos de CPU permitem que determinadas partes do dispositivo sejam assíncronas, como o uso de Unidades Lógicas e Aritméticas (ULAs) assíncronas em conjunto com pipeline superscalar para alcançar alguns ganhos de desempenho aritmético. Embora não esteja totalmente claro se projetos totalmente assíncronos podem ter um desempenho comparável ou melhor do que seus equivalentes síncronos, é evidente que eles se sobressaem em operações matemáticas mais simples. Isso, combinado com suas excelentes propriedades de consumo de energia e dissipação de calor, os torna muito adequados para computadores embarcados. 


== Ver também ==
Processador multinúcleo
Engenharia de computação
Digital Signal Processor
Unidade de processamento gráfico
Computador com um Conjunto Complexo de Instruções
Barramento
Soquete de CPU


== Notas ==


== Referências ==