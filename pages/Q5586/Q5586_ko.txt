고급 암호화 표준(Advanced Encryption Standard, AES)은 2001년 미국 표준 기술 연구소(NIST)에 의해 제정된 암호화 방식이다. AES는 두 명의 벨기에 암호학자인 요안 다먼과 빈센트 레이먼에 의해 개발된 Rijndael(레인달, [rɛindaːl]) 에 기반하며 AES 공모전에서 선정되었다.
AES는 미국 정부가 채택한 이후 전 세계적으로 널리 사용되고 있다. 1977년 공표된 DES를 대체한 AES는, 암호화와 복호화 과정에서 동일한 키를 사용하는 대칭 키 알고리즘이다.
미국 표준 기술 연구소(NIST)는 2001년 11월 26일 AES를 미국 연방 정보 처리 표준(FIPS-197)으로 공포하였다. NIST는 5년의 표준화 과정을 거쳤으며 이 과정에서 15개의 알고리즘이 경쟁, Rijndael 암호가 가장 적합한 알고리즘으로 선정되었다. 이 표준은 2002년 5월 26일부터 효력을 발휘하기 시작했다. AES는 ISO/IEC 18033-3 표준에 포함되어 있으며 여러 암호화 패키지에서 사용되고 있다. AES는 또한 미 국가안보국에 의해 1급비밀(Top Secret)에 사용할 수 있도록 승인된 알고리즘 중 최초로 공개되어 있는 알고리즘이다.
Rijndael은 알고리즘의 개발자인 빈센트 레이먼(Vincent Rijmen)과 요안 다먼(Joan Daemen)의 이름을 따서 지은 것으로  AES 표준은 여러 Rijndael 알고리즘 중 블록 크기가 128비트인 알고리즘을 말한다.


== 표준 ==
AES는 다음 각각에 정의되어 있다:

FIPS PUB 197: Advanced Encryption Standard (AES)
ISO/IEC 18033-3: Block ciphers


== 개요 ==
1997년 1월 2일 NIST(National Institute of Standards and Technology)는 DES를 대체할 목적으로 3DES와 같거나 더 나은 보안성을 갖고 개선된 암호 기법을 공모하였다. 선정될 암호의 정식 명칭은 1997년 9월 2일 AES(Advanced Encryption Standard)로 정해졌다. NIST는 암호론의 케르코프 원리(Kerckhoffs' principle, 대칭 블록)에 의해 128비트 블록을 128혹은 192혹은 256비트 키 길이로 처리할 수 있고, 무료로 배포할 수 있어야 한다는 제한 조건이 있었다. 평가 항목으로는 보안, 계산적 효율성, 메모리 요구량, 하드웨어와 소프트웨어적 적합성, 유연성 5가지를 제시하였다. 마감일인 1998년 1월 15일까지 21개의 암호 알고리즘이 제안되었고 그 중 15개 암호 알고리즘이 AES 후보로 선정되어 안전성을 평가 받았다. NIST는 15개의 암호 알고리즘에 대하여 제1차 AES 후보 대회(First AES Candidate Conference)를 1998년 8월 20일에 개최 하였고 제2차 AES 후보 대회(Second AES Candidate Conference)를 1999년 3월에 개최하였으며 이후, 1999년 8월에는 5개의 후보 알고리즘을 최종 후보로 선정하여 많은 암호학자들로부터 안전성 평가를 받게 하였다. 이 때, 남은 5개 알고리즘의 이름은 MARS, RC6, 레인달(Rijndael), Serpent, Twofish였다. 그리고 2000년 4월 3차 대회가 개최되고 2000년 10월 2일 AES 알고리즘으로 레인달을 선정하였다. 이어 NIST는 2001년 2월 28일에 연방 정보 처리 표준으로 AES를 공개/리뷰/배포 하면서 기밀성있는 정보에 DES를 대체하여 AES를 사용하기 시작한다. 2001년 11월 16일에는 표준으로 채택되었으며 2001년 12월 4일에는 FIPS 197로 등록 되었다.
AES 선정과정에서 주목해야할 점은 개방성과 국제 흐름을 반영하였다는 점이다. 세 번의 대회와 많은 사람들(전문가/비전문가)의 의견을 공개/반영 하였으며 피드백의 기회를 부여하고 다함께 이슈에 대하여 토론하는 과정이 있었다. 뿐만 아니라 다양한 분야의 전문가들의 의견이 반영 되었다. 수학자, 컴퓨터 학자, 암호학자, 공학자등 다양한 분야의 전문가들이 의견을 적극적으로 반영하여 안전하면서도 훌륭한 성능을 갖춘 알고리즘을 선택할 수 있었다. 국제화 측면에서 AES는 15개의 후보 알고리즘의 저자들의 국적 만큼이나 다양한 국가의 평가를 받았다. 당시 알고리즘 안전성 평가에 적극적이었던 국가로는 대한민국을 비롯하여 일본, 이스라엘, 독일, 프랑스, 코스타리카, 캐나다, 벨기에, 호주, 노르웨이, 영국, 미국이 있었다. 레인달은 Daemen과 Rijmen이라는 두 명의 벨기에 연구원에 의해 설계되었다. AES 선정과정에서 재밌는 점 중 다른 하나는 2차 대회가 미국이 아닌 이탈리아 로마에서 개최되었다는 점이다. AES 후보 알고리즘들은 다음과 같은 세가지 조건을 만족해야 했다.

안전성(security)
비용(cost)
알고리즘 및 구현 특성(algorithm and implementation characteristics)
"안전성"은 절대적으로 갖춰야 하는 부분이었으며 특히 당시 대칭키 암호를 분석하는 방법인 '선형 공격(linear cryptanalysis)'과 '차분 공격(Differential cryptanalysis)'에 대한 안전성 증명이 주를 이루었다.
"비용"은 '스마트 카드, 하드웨어, 소프트웨어, 구현'을 위한 다양한 형태의 계산효율성(computational efficiency)을 참고하여 평가 되었다. 여기서 계산효율성이라고 하는 것은 속도 및 메모리 요구량(speed and memory requirement)등을 의미 하였다.
"알고리즘 및 구현 특성"은 유연성(Flexibility)과 알고리즘의 단순성(simplicity)을 주로 평가 하였다.
마지막 평가과정에서 남았던 5개의 알고리즘 중 4개의 알고리즘은 탈락했지만 안전성이 떨어지는 알고리즘은 절대 아니였다.
다만 Rijndael의 알고리즘이 안전성, 속도, 효율성, 구현 및 유연성이 다른 알고리즘들 보다 우수했을 뿐이다.


== 알고리즘 개요 ==

이 구조에서 주목할 만한 특징 중 하나는 이 구조가 파이스텔 구조가 아니라는 것이다. 전형적인 파이스텔 구조를 떠올려 보면 데이터 블록 반쪽을 다른 반쪽을 수정하는 데 사용했고 그 두 반쪽을 교환하였다. AES는 파이스텔 구조를 사용하지 않고 각 라운드에서 대체(substitution)와 치환(permutation)을 이용해서 데이터 블록 전체를 병렬 처리한다.
AES-128을 사용한다면, 입력으로 사용하는 라운드 키를 44개의 32비트 워드 배열 w[i]로 확장한다. 4개의 서로 다른 워드(128비트 = 4 * 32비트)를 각 라운드에서 라운드 키로 사용한다. 44개의 워드가 되는 이유는 AES-128의 경우, 총 11 라운드 키가 필요하기 때문이다.
다음 네 가지 단계를 이용하는데, 한 번의 치환과 세 번의 대체이다.
바이트 대체(Substitute bytes): S-box라는 표를 이용하여 바이트 단위(byte-to-byte) 형태로 블록을 교환한다.
행 이동(Shift rows) : 단순히 행과 행을 치환한다.
열 섞기(Mix columns) : 열에 속한 모든 바이트를 순환 행렬을 사용해 함수로 열에 있는 각 바이트를 대체하여 변화시킨다.
라운드 키 더하기(Add round key) : 확장된 키의 일부와 현재 블록을 비트별로 XOR한다.
암호와 복호를 위해서 라운드 키 더하기 단계에서 시작하고, 각 라운드에서는 4단계를 모두 포함하는 9라운드를 수행하고, 3단계로 구성된 10번째 라운드를 수행한다.
오직 라운드 키 더하기 단계에서만 키를 사용한다. 그래서 암호와 복호 과정의 시작과 끝은 항상 라운드 키 더하기 단계이다. 시작이나 끝에 수행되는 다른 단계는 키 없이 역방향 계산이 가능하기 때문에 보안을 강화시키는 데는 아무 역할도 하지 못한다.
라운드 키 더하기 단계는 그 자체가 강력하지 못대는 대신 다른 세 단계와 같이 작동하여 비트를 뒤섞는 역할을 한다. 하지만 각각은 키를 사용하지 않으므로 보안성을 제공하는 것은 아니다. 이 암호 단계를 살펴보면 블록에 XOR 암호화(라운드 키 더하기)를 하고, 그 다음 블록을 뒤섞고(다른 세 단계), 그 뒤에 다시 XOR 암호화를 하는 것으로 이를 번갈아서 적용하는 것을 볼 수 있다. 이 구조는 효과적이고 보안성을 매우 강화시킨다.
각 단계를 역으로 계산하기는 쉽다. 바이트 대체, 행이동, 열 섞기 단계는 복호 알고리즘에서 사용되는 역함수이다, 라운드 키 더하기 단계에서는 같은 라운드 키를 블록에 XOR 수행하여 역을 계산한다.
대부분 블록 암호가 그렇듯 복호 알고리즘에서는 확장 키를 순서를 뒤집어서 적용한다. 그러나 복호 알고리즘이 암호 알고리즘과 동일하지는 않다. 이것이 AES구조가 가지고 있는 특성이다.
4단계가 모두 역 계산이 가능하므로 복호화를 하면 평문을 얻을 수 있다는 것은 당연하다.
암호와 복호의 마지막 라운드는 오직 세 단계로만 구성된다. 이것이 AES구조가 가진 특성이고, 이 특성은 AES암호가 역으로 작동되기 위해 필요한 것이다.


== AES 최적화(Table을 이용하는 방법) ==

Subbyte와 Shiftrows 순서를 바꾸는 게 가능하므로 암호화 한 라운드를 Shiftrows -> Subbyte&Mixcolumns -> Addroundkey 순서로 변경한다.
Subbyte&Mixcolumns을 8*32 table 4개로 구현한다. 32비트 수 4개가 입력으로 들어왔을 때 1개의 수 x = (a<<24)+(b<<16)+(c<<8)+d라고 했을 때 이를 행렬로 표현하면  
  
    
      
        
          
            [
            
              
                
                  a
                
              
              
                
                  b
                
              
              
                
                  c
                
              
              
                
                  d
                
              
            
            ]
          
        
      
    
    {\displaystyle {\begin{bmatrix}a\\b\\c\\d\end{bmatrix}}}
  
이며 순환행렬을 곱해서 다시 32비트 수로 변환하게 되면 행렬곱을 이용해서 ((2*a+3*b+1*c+1*d)<<24)+((1*a+2*b+3*c+1*d)<<16)+((1*a+1*b+2*c+3*d)<< 8)+(3*a+1*b+1*c+2*d)가 된다. 이때 곱하기는 갈루아 필드에서의 다항식 곱셈연산이 된다. table을 4개 생성을 하고 각 테이블에는 a,b,c,d를 입력받는다.

Table0생성 : 입력받은 a에 Subbyte연산을 수행하면 Sbox[a]가 된다. ((2*Sbox[a])<<24)+((1*Sbox[a])<<16)+((1*Sbox[a])<<8)+3*Sbox[a]연산을 하여 출력한다.
Table1생성 : 입력받은 b에 Subbyte연산을 수행하면 Sbox[b]가 된다. ((3*Sbox[b])<<24)+((2*Sbox[b])<<16)+((1*Sbox[b])<<8)+1*Sbox[b]연산을 하여 출력한다.
Table2생성 : 입력받은 c에 Subbyte연산을 수행하면 Sbox[c]가 된다. ((1*Sbox[c])<<24)+((3*Sbox[c])<<16)+((2*Sbox[c])<<8)+1*Sbox[c]연산을 하여 출력한다.
Table3생성 : 입력받은 d에 Subbyte연산을 수행하면 Sbox[d]가 된다. ((1*Sbox[d])<<24)+((1*Sbox[d])<<16)+((*Sbox[d])<<8)+3*Sbox[d]연산을 하여 출력한다.
Subbyte&Mixcolumns연산을 끝낸 32비트 x는 Table0[x>>24] ^ Table1[(x>>16)&0xff] ^ Table2[(x>>8)&0xff] ^ Table3[x&0xff]이 된다.
위와 같이 TABLE을 이용하여 암호화 구현시에는 Sbox표를 입력해놓을 필요가 없다. 순환행렬에서의 1을 이용하여 Table1결과값(((3*sbox[b])<<24)+((2*sbox[b])<<16)+((1*sbox[b])<<8)+1*sbox[b])에 LSB에서부터 8비트(1*sbox[b])만 이용하면 Sbox와 동일한 값이 된다. 하지만 복호화 구현시에는 복호화 Mixcolumn 수행 시 사용되는 순환행렬에는 1이 없기 때문에 InvSbox표가 필요하다.
복호화 수행 시 동일한 방법으로 Table 4개를 생성한다. 이때 복호화는 한 라운드가 Addroundkey -> InvMixcolumns -> InvShiftrows -> InvSubbyte 식으로 수행이 된다. 이때 첫번째와 마지막 복호화키를 제외한 복호화키에 InvMixcolumn연산을 해주면 InvSubbyte -> InvShiftrows -> InvMixcolumns -> Addroundkey 방법으로 구현이 가능하다.
InvSubbyte&InvMixcolumns을 8*32 table 4개로 구현한다. 32비트 수 4개가 입력으로 들어왔을 때 1개의 수 x = (a<<24)+(b<<16)+(c<<8)+d라고 했을 때 이를 행렬로 표현하면  
  
    
      
        
          
            [
            
              
                
                  a
                
              
              
                
                  b
                
              
              
                
                  c
                
              
              
                
                  d
                
              
            
            ]
          
        
      
    
    {\displaystyle {\begin{bmatrix}a\\b\\c\\d\end{bmatrix}}}
  
이며 순환행렬을 곱해서 다시 32비트 수로 변환하게 되면 행렬곱을 이용해서 ((14*a+11*b+13*c+9*d)<<24)+((9*a+14*b+11*c+13*d)<<16)+((13*a+9*b+14*c+11*d)<< 8)+(11*a+13*b+9*c+14*d)가 된다. 이때 곱하기는 갈루아 필드에서의 다항식 곱셈연산이 된다. table을 4개 생성을 하고 각 테이블에는 a,b,c,d를 입력받는다.

Table0생성 : 입력받은 a에 Invsubbyte연산을 수행하면 InvSbox[a]가 된다. ((14*InvSbox[a])<<24)+((9*InvSbox[a])<<16)+((13*InvSbox[a])<<8)+11*InvSbox[a]연산을 하여 출력한다.
Table1생성 : 입력받은 b에 Invsubbyte연산을 수행하면 InvSbox[b]가 된다. ((11*InvSbox[b])<<24)+((14*InvSbox[b])<<16)+((9*InvSbox[b])<<8)+13*InvSbox[b]연산을 하여 출력한다.
Table2생성 : 입력받은 c에 Invsubbyte연산을 수행하면 InvSbox[c]가 된다. ((13*InvSbox[c])<<24)+((11*InvSbox[c])<<16)+((14*InvSbox[c])<<8)+9*InvSbox[c]연산을 하여 출력한다.
Table3생성 : 입력받은 d에 subbyte연산을 수행하면 InvSbox[d]가 된다. ((9*InvSbox[d])<<24)+((13*InvSbox[d])<<16)+((11*InvSbox[d])<<8)+14*InvSbox[d]연산을 하여 출력한다.
InvSubbyte&InvMixcolumns연산을 끝낸 32비트 x는 Table0[x>>24] ^ Table1[(x>>16)&0xff] ^ Table2[(x>>8)&0xff] ^ Table3[x&0xff]이 된다.
Table 생성 결과


== 같이 보기 ==
SEED — AES와 유사하며 대한민국에서 개발한 블록 암호 형식.
Botan - AES에 사용되는 라이브러리의 하나.


== 각주 ==

내용주


== 외부 링크 ==
“256bit key – 128bit block – AES”. 《Cryptography – 256 bit Ciphers: Reference source code and submissions to international cryptographic designs contests》. EmbeddedSW. 
“Advanced Encryption Standard (AES)” (PDF). 《Federal Information Processing Standards》. 2001년 11월 26일. doi:10.6028/NIST.FIPS.197. 197. 
“Part 3: Block ciphers” (PDF). 《Information technology – Security techniques – Encryption algorithms》 2판. ISO. 2010년 12월 15일. ISO/IEC 18033-3:2010(E). 2022년 10월 9일에 원본 문서 (PDF)에서 보존된 문서. 
Animation of Rijndael – AES deeply explained and animated using Flash (by Enrique Zabala / University ORT / Montevideo / Uruguay). This animation (in English, Spanish, and German) is also part of CrypTool 1 (menu Indiv. Procedures → Visualization of Algorithms → AES).
HTML5 Animation of Rijndael – Same Animation as above made in HTML5.
256bit Ciphers - AES Reference implementation and derived code